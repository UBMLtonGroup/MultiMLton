<HTML
><HEAD
><TITLE
>The Portable OS API</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="The Basis Library"
HREF="c710.html"><LINK
REL="PREVIOUS"
TITLE="The Portable I/O API"
HREF="x1003.html"><LINK
REL="NEXT"
TITLE="The POSIX API"
HREF="x1164.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x1003.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. The Basis Library</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x1164.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN1065"
>The Portable OS API</A
></H1
><P
>The Basis library provides a portable API for operating system-level
operations.  These deal in processes, file systems, time, date and
device-specific I/O attributes, and models for manipulating these
resources that are largely system-independent.  In the Basis documentation
this API is described under the heading of &quot;System&quot;.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>OS</TT
> structure contains part of the API in the substructures
<TT
CLASS="COMPUTEROUTPUT"
>FileSys</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>Path</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>Process</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>IO</TT
> as well as some
common exception and error handling functions.  The <TT
CLASS="COMPUTEROUTPUT"
>OS.FileSys</TT
>
structure provides an API for scanning directories, altering directories
by deleting or renaming files and checking access permission. You can
get and change the current directory here too.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>OS.Path</TT
> provides an abstract view of file paths.
The <TT
CLASS="COMPUTEROUTPUT"
>OS.Process</TT
> structure provides a few process-oriented
functions that are still rather Unix specific.  The <TT
CLASS="COMPUTEROUTPUT"
>OS.IO</TT
>
structure provides an interface to the Posix <TT
CLASS="COMPUTEROUTPUT"
>poll</TT
> system call.
Presumably it can be implemented in terms of other system calls on other
operating systems. I'll ignore it.</P
><P
>The signatures for the OS API can be found in the <TT
CLASS="COMPUTEROUTPUT"
>boot/OS</TT
>
directory of the compiler.  Most of the implementation can be found in
the <TT
CLASS="COMPUTEROUTPUT"
>boot/Unix</TT
> directory for Posix-based Unix systems. </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1083"
><TT
CLASS="COMPUTEROUTPUT"
>OS.FileSys</TT
></A
></H2
><P
>The file system API is straight-forward enough.  I'll illustrate it with a
program to scan a directory tree looking for writable executable files
on the grounds that these might be a security hazard.  Symbolic links
won't be followed.  I start with some useful declarations.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>structure FS = OS.FileSys
structure OP = OS.Path

fun toErr msg = TextIO.output(TextIO.stdErr, msg)

exception Error of string</PRE
></TD
></TR
></TABLE
><P
>The structure declarations just provide convenient shorthand names.
I've added my own Error exception so that I can report more meaningful
context-sensitive errors.  </P
><P
>Here is the main function. </P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun main(arg0, argv) =
let
in
    case argv of
      [] =&#62; scan_dir OP.currentArc

    | (file::_) =&#62; scan_dir file;

    OS.Process.success
end
handle
  OS.SysErr (msg, _) =&#62;
    (
        toErr(concat["System Error: ", msg, "\n"]);
        OS.Process.failure
    )

| Error msg =&#62; (toErr msg; OS.Process.failure)

| x =&#62; (toErr(concat["Uncaught exception: ", exnMessage x,"\n"]);
        OS.Process.failure)</PRE
></TD
></TR
></TABLE
><P
>The program  will take a directory name on the command line or if one is
omitted then the current directory is used.  The <TT
CLASS="COMPUTEROUTPUT"
>OS.Path.currentArc</TT
>
function provides a portable way to represent the current directory.
Errors that I expect from user input are reported via the <TT
CLASS="COMPUTEROUTPUT"
>Error</TT
>
handler. But I also catch other <TT
CLASS="COMPUTEROUTPUT"
>OS.SysErr</TT
> exceptions just in case.</P
><P
>I open a directory with the following function.  It catches the
<TT
CLASS="COMPUTEROUTPUT"
>OS.SysErr</TT
> exception and turns it into a more meaningful error
message.  (The optional <TT
CLASS="COMPUTEROUTPUT"
>syserror</TT
> code in the exception is redundant).</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun open_dir dir =
(
    FS.openDir dir
)
handle 
  OS.SysErr (msg, _) =&#62; raise Error (concat[
            "Cannot open directory ", dir, ": ", msg, "\n"])</PRE
></TD
></TR
></TABLE
><P
>Finally here is the directory scanning function.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun scan_dir dir =
let
    (* val _ = print(concat["scan_dir ", dir, "\n"]) *)
    val strm = open_dir dir

    fun get_files files =
    (
        case FS.readDir strm of
          "" =&#62; rev files           (* done *)

        | f =&#62; 
            let
                val file = OP.joinDirFile
                            {dir = dir, file = f}
            in
                if FS.isLink file
                then
                    get_files files
                else
                    get_files (file::files)
            end
    )

    val files = get_files []
    val _     = FS.closeDir strm

    fun show_wx file =
    (
        if FS.access(file, [FS.A_WRITE, FS.A_EXEC])
        then
            (print file; print "\n")
        else
            ()
    )

    fun scan_subdir file =
    (
        if FS.isDir file
        then
            scan_dir file
        else
            ()
    )
in
    app show_wx files;
    app scan_subdir files
end</PRE
></TD
></TR
></TABLE
><P
>The first line is just some tracing I used while debugging the function.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>val</TT
> declarations are executed in the order that they appear.
This is important since they may have side-effects.  The <TT
CLASS="COMPUTEROUTPUT"
>get_files</TT
>
function reads the stream to build a list of files in the directory.
It comes after the <TT
CLASS="COMPUTEROUTPUT"
>strm</TT
> name is defined because it refers to it
as a global name.  The directory stream is updated imperatively by the
<TT
CLASS="COMPUTEROUTPUT"
>readDir</TT
> function.  The <TT
CLASS="COMPUTEROUTPUT"
>OS.Path.joinDirFile</TT
> function is a
portable way to add a path element. It will use the right kind of slash.</P
><P
>I want to avoid accumulating open directories while walking the directory
tree as I might run out of open files if the tree is too deep.  So instead
I extract the files and close the directory stream.  This means that I
will be retaining in memory all of the files in the directories along a
path through the tree. File paths will be discarded on the way back up
the tree so the garbage collector can reclaim them if needed.  There is
lots more memory than there are available file descriptors.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>show_wx</TT
> function prints the file name if it is writable and
executable.  It is iterated over the list of files using the built-in
<TT
CLASS="COMPUTEROUTPUT"
>app</TT
> function (see <A
HREF="x964.html"
>the section called <I
>Lists</I
></A
>).  I recurse in
<TT
CLASS="COMPUTEROUTPUT"
>scan_subdir</TT
> by scanning each file that is a directory.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1114"
><TT
CLASS="COMPUTEROUTPUT"
>OS.Path</TT
></A
></H2
><P
>The functions in <TT
CLASS="COMPUTEROUTPUT"
>OS.Path</TT
> model a file path as a list of names called
arcs. There is also provision for a volume name for Microsoft Windows.
File names can have an extension marked by a &quot;.&quot; character.  There are
functions for splitting and joining all of these kinds of parts.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1119"
><TT
CLASS="COMPUTEROUTPUT"
>OS.Process</TT
></A
></H2
><P
>Your main interest in <TT
CLASS="COMPUTEROUTPUT"
>OS.Process</TT
> is for the <TT
CLASS="COMPUTEROUTPUT"
>success</TT
>
and <TT
CLASS="COMPUTEROUTPUT"
>failure</TT
> values which are needed as exit codes for your main
program.  The <TT
CLASS="COMPUTEROUTPUT"
>system</TT
> command for running shell commands could be
useful but if you want to capture the output see the functions in the
<TT
CLASS="COMPUTEROUTPUT"
>Unix</TT
> structure.  </P
><P
>You can abort your program early with the <TT
CLASS="COMPUTEROUTPUT"
>exit</TT
> or <TT
CLASS="COMPUTEROUTPUT"
>terminate</TT
>
functions but I prefer to use an exception for fatal errors. It leaves
open the possibility of higher-level functions trapping the errors.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>getEnv</TT
> function gets environment variables like the C library's
<TT
CLASS="COMPUTEROUTPUT"
>getenv()</TT
> function.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1134"
>Time and Date</A
></H2
><P
>Time and Date values are provided in the <TT
CLASS="COMPUTEROUTPUT"
>Time</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>Date</TT
>
structures respectively. They are documented in the Basis library under
the &quot;System&quot; heading.  Their implementations appear in the <TT
CLASS="COMPUTEROUTPUT"
>boot/</TT
>
directory of the compiler.</P
><P
>Time values in SML/NJ are stored as a pair of seconds and microseconds.</P
><P
>The main trick to remember with the <TT
CLASS="COMPUTEROUTPUT"
>time</TT
> type is that the top-level
operators are not overloaded on them.  So if you want to subtract two
time values you need to write something like <TT
CLASS="COMPUTEROUTPUT"
>Time.-(t1, t2)</TT
>.
Similarly for the other symbolic functions in <TT
CLASS="COMPUTEROUTPUT"
>Time</TT
>.</P
><P
>Also the conversion with integer values uses the <TT
CLASS="COMPUTEROUTPUT"
>LargeInt</TT
> structure
which on 32-bit systems is the same as <TT
CLASS="COMPUTEROUTPUT"
>Int32</TT
> i.e. boxed 32-bit
integers.  (See <A
HREF="x892.html"
>the section called <I
>Integers</I
></A
>).</P
><P
>You can convert a date represented as the number of seconds since the
Unix epoch to a year/month/day representation using the Time and Date
structures.  Write something like this:</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val date = Date.fromTimeLocal(Time.fromSeconds 99999999)
val year = Date.year date</PRE
></TD
></TR
></TABLE
><P
>The month and day of the week is represented by the enumeration types
<TT
CLASS="COMPUTEROUTPUT"
>weekday</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>month</TT
> in <TT
CLASS="COMPUTEROUTPUT"
>Date</TT
>.  There is no mechanism
for converting these values to integers or strings.  You'll have to write
your own.  What you can do though is use the <TT
CLASS="COMPUTEROUTPUT"
>Date.fmt</TT
> function to
format a date any way you like. It uses the <TT
CLASS="COMPUTEROUTPUT"
>strftime()</TT
> C library
function underneath so the result should be properly locale-dependent.</P
><P
>At the time of writing, SML/NJ has not implemented the
<TT
CLASS="COMPUTEROUTPUT"
>Date.fromString</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>Date.scan</TT
> functions.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1160"
>Unix</A
></H2
><P
>The &quot;System&quot; documention for the Basis library describes a Unix structure.
It's not really a portable OS thing. It just provides some simple utility
functions for spawning a sub-process, talking to it through stdin and
stdout and killing it afterwards.  The source for it can be found in
the <TT
CLASS="COMPUTEROUTPUT"
>boot/Unix</TT
> directory of the compiler.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x1003.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x1164.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>The Portable I/O API</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c710.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>The POSIX API</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
