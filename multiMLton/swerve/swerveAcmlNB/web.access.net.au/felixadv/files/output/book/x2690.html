<HTML
><HEAD
><TITLE
>Getting the Value with a Time-Out</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="Concurrency"
HREF="c2344.html"><LINK
REL="PREVIOUS"
TITLE="Getting the Value through an Event"
HREF="x2669.html"><LINK
REL="NEXT"
TITLE="More on Time-Outs"
HREF="x2739.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x2669.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 6. Concurrency</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x2739.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="COUNTERTIMEOUT"
>Getting the Value with a Time-Out</A
></H1
><P
>The next example shows the alternative implementation with the commit
point in the reply phase.  This could be used by the client with a
1 second time-out with code like this.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val time_out: int -&#62; int CML.event
...
select [Counter.getEvt cnt, time_out 1]</PRE
></TD
></TR
></TABLE
><P
>As soon as the <TT
CLASS="COMPUTEROUTPUT"
>select</TT
> starts waiting for these events I want the
request to be sent to the counter. If the reply is not ready before the
time-out event is enabled then the reply must be discarded.  Note that
for type correctness the time-out event must be able to deliver an
integer the same as the counter does.</P
><P
>The first version of this example uses a channel to carry the reply.
When the counter attempts to reply it must not become blocked while
waiting for the client to accept the reply, otherwise we will lose
concurrency in the program.  Since sending to a channel can block,
a separate thread must be spawned to deliver the reply while the
counter goes on to handle the next request.  So we can have more than
one outstanding reply to different clients. There will have to be a
different reply channel for each client.</P
><P
>Similarly the client should not be blocked waiting for the counter
to receive the request as this may delay the start of the time-out or
prevent delivery of the time-out event.  So the request will be sent
from a separate thread as well.</P
><P
>Here are the message types.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>structure Counter: COUNTER =
struct

    datatype Request = 
            ReqIsIncr of int
        |   ReqIsGet of Reply CML.chan

    and Reply =
            ReplyIsCount of int

    and Counter = Counter of {
                    req_chan:   Request CML.chan
                    }</PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>Counter</TT
> record no longer holds a reply channel.  Instead one
is passed along with the <TT
CLASS="COMPUTEROUTPUT"
>ReqIsGet</TT
> message.  Here is the <TT
CLASS="COMPUTEROUTPUT"
>new</TT
>
function with the updated counter implementation.  I've added a time
delay into the reply for testing.  If you change the delay to 2 seconds
the client, shown below, will time-out.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun new init =
let
    val req_chan = CML.channel()

    fun counter() =
    let
        fun loop count =
        (
            case CML.recv req_chan of
              ReqIsIncr n =&#62; loop (count + n)

            | ReqIsGet rpl_chan =&#62; 
            let
                fun reply() =
                (
                    delay 0;
                    CML.send(rpl_chan, ReplyIsCount count)
                )
            in
                CML.spawn reply;
                loop count
            end
        )
    in
        loop init
    end

    val thread = CML.spawn counter
in
    Counter
    {
        req_chan = req_chan
    }
end</PRE
></TD
></TR
></TABLE
><P
>Here is the time delay function.  Don't use the <TT
CLASS="COMPUTEROUTPUT"
>Posix.Process.sleep</TT
>
function or anything similar as it will pause the entire program,
not just one thread.  See <A
HREF="x2739.html"
>the section called <I
>More on Time-Outs</I
></A
> for more details.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun delay n = CML.sync (CML.timeOutEvt (Time.fromSeconds n))</PRE
></TD
></TR
></TABLE
><P
>Here is the updated implementation of the <TT
CLASS="COMPUTEROUTPUT"
>getEvt</TT
> function.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun getEvt (Counter {req_chan, ...}) =
let
    fun send() =
    let
        val rpl_chan = CML.channel()

        fun recv (ReplyIsCount n) = n
        fun sender() = CML.send(req_chan, ReqIsGet rpl_chan)
    in
        CML.spawn sender;
        CML.wrap(CML.recvEvt rpl_chan, recv)
    end
in
    CML.guard send
end</PRE
></TD
></TR
></TABLE
><P
>This returns an event that is constructed by the <TT
CLASS="COMPUTEROUTPUT"
>recvEvt</TT
> function
and is wrapped in both the <TT
CLASS="COMPUTEROUTPUT"
>send</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>recv</TT
> functions.
The <TT
CLASS="COMPUTEROUTPUT"
>guard</TT
> delays the sending of the message until an attempt
is made to synchronise on the event using for example <TT
CLASS="COMPUTEROUTPUT"
>select</TT
>
as shown above.  Then a thread is spawned to send the Get request
asynchronously and an event to represent the reception of the reply
is constructed. This event is wrapped with the <TT
CLASS="COMPUTEROUTPUT"
>recv</TT
> function to
unpack the integer count in the reply.  It is this receive event that
is returned and waited on by the client along-side the time-out.</P
><P
>Finally to demonstrate the time-out I've changed the driver function.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun run() =
let
    val obj = Counter.new 0

    fun time_out t = CML.wrap(
                        CML.timeOutEvt(Time.fromSeconds t),
                        fn () =&#62; ~1)
in
    Counter.incr obj 3;
    Counter.incr obj ~1;

    let
        val c = CML.select [Counter.getEvt obj, time_out 1]
    in
        print(concat["The counter's value is ",
                     Int.toString c, "\n"])
    end
end</PRE
></TD
></TR
></TABLE
><P
>Here I've added a <TT
CLASS="COMPUTEROUTPUT"
>time_out</TT
> function that delivers a count of -1 if the
time-out expires.</P
><P
>It might seem that there is a risk that one of the spawned threads will
get stuck forever if either the client or the counter fails to complete
the interaction.  But the garbage collector can determine if a channel
operation can never complete because no other threads reference the
channel.  So all of these spawned threads will be cleaned up properly
even if there is a time-out.</P
><P
><A
HREF="x2690.html#CNT4INTER"
>Figure 6-6</A
> shows the client getting the counter's value with
and without a time-out.  When there is no time-out, the <TT
CLASS="COMPUTEROUTPUT"
>select</TT
> will
choose to receive the reply.  When there is a time-out the select will
receive a time-out message that is triggered by the <TT
CLASS="COMPUTEROUTPUT"
>CML.timeOutEvt</TT
>
function.  The reply thread running the reply function will block
indefinitely.  When the garbage collector collects the event from
<TT
CLASS="COMPUTEROUTPUT"
>getEvt</TT
> all references to the reply channel outside of the reply
thread will disappear and the reply thread will be collected too.</P
><DIV
CLASS="FIGURE"
><A
NAME="CNT4INTER"
></A
><P
><B
>Figure 6-6. Getting the Value with a Time-Out</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><center><IMG
SRC="concur/cnt4Inter.png"
></center></IMG
></P
></DIV
></DIV
><P
>Here is a more stream-lined version using an I-variable (see
<A
HREF="x2442.html#CMLSYNCVARS"
>the section called <I
>Synchronous Variables</I
></A
>) to return the reply.  Writing into an
I-variable never blocks.  If there is already a value in the variable
then that is an error which raises an exception.  But the counter will
only reply once.  So the counter doesn't need to protect itself against
blocking by spawning a thread for the reply.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>structure Counter: COUNTER =
struct

    datatype Request = 
            ReqIsIncr of int
        |   ReqIsGet of int SyncVar.ivar

    and Counter = Counter of {
                    req_chan:   Request CML.chan
                    }
... omitted material ...</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun counter() =
let
    fun loop count =
    (
        case CML.recv req_chan of
          ReqIsIncr n =&#62; loop (count + n)

        | ReqIsGet rpl_var =&#62; 
        (
            (* delay 2; *)
            SyncVar.iPut(rpl_var, count);
            loop count
        )
    )
in
    loop init
end
... omitted material ...</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun getEvt (Counter {req_chan, ...}) =
let
    fun send() =
    let
        val rpl_var = SyncVar.iVar()

        fun sender() = CML.send(req_chan, ReqIsGet rpl_var)
    in
        CML.spawn sender;
        SyncVar.iGetEvt rpl_var
    end
in
    CML.guard send
end</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x2669.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x2739.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Getting the Value through an Event</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c2344.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>More on Time-Outs</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
