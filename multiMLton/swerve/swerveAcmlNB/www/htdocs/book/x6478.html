<HTML
><HEAD
><TITLE
>Type Errors</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="Coping with the Compiler's Error Messages"
HREF="a6445.html"><LINK
REL="PREVIOUS"
TITLE="Record Errors"
HREF="x6465.html"><LINK
REL="NEXT"
TITLE="Installation"
HREF="a6548.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x6465.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Appendix B. Coping with the Compiler's Error Messages</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="a6548.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN6478"
>Type Errors</A
></H1
><P
>The SML language is designed so that you can write your code without
having to declare each variable with its type.  Ideally you should be
able to write no types anywhere and the compiler can figure out the type
of each expression entirely by context.  The language comes very close
to this ideal. Only some ambiguities with overloaded numeric literals
and record patterns spoil it.</P
><P
>Type expressions in SML can be quite complex. If a function is polymorphic
then its type will feature type variables which will be tiresome to
get straight.  Having the type checker figure them out for you is a
big advantage.</P
><P
>The disadvantage of this design is that when there is a type error the
cause of the error can be very obscure.  Where an identifier is used in
several locations in your program the type checker compares each location
to see if the use is consistent.  For example if you use an identifier as
the argument to a function that takes a string and also to one that takes
an integer then the identifier can't be both a string and an integer.
You will have to decide which one is wrong.  If you use the identifier
in a great many locations you may have to inspect all of them to find
out which one is incorrect.</P
><P
>When the type checker is studying your program it reads it from top to
bottom and decides on the type of an identifier from the first location it
encounters that supplies it with decisive information.  Every following
location is checked against this type and if there is a mismatch then an
error is reported.  If it happens that the first location is the wrong
one then all of the remaining locations will report errors.</P
><P
>The message that is generated for each type error will typically contain
an abstract of the offending source code and a report of two type
expressions that didn't match.  Usually the code is a function call and
the mismatch is between the expected type of the argument and the actual
type of the argument expression.  To figure out the type error you have
to compare the two type expressions.  They often contain internal type
variables written like <TT
CLASS="COMPUTEROUTPUT"
>'Z</TT
>. A type variable will match with any
type. Type variables with the same letter in the same type expression
must be the same type.</P
><P
>Sometimes you will reach a point where the type checker insists that
there is an error at some location and you are sure that it's not
there but somewhere else. A good strategy is to put in an explicit
type constraint to point out to the type checker what you think the
type must be. The checker will then point out any other locations that
don't match that type.  You can put a type constraint on any expression,
including literals.</P
><P
>The following sections show some typical examples and what went wrong
in each case.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN6488"
>Simple Type Errors</A
></H2
><P
>The simplest error is an argument mismatch when the argument type
is obvious.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun f() = print 3</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type1a.sml:1.11-1.18 Error: operator and operand don't agree [literal]
  operator domain: string
  operand:         int
  in expression:
    print 3</PRE
></TD
></TR
></TABLE
><P
>The message talks about an operator, the function, and an operand,
its argument.  The domain of an operator is the type that it expects.
In this case it expected a <TT
CLASS="COMPUTEROUTPUT"
>string</TT
> and was given an <TT
CLASS="COMPUTEROUTPUT"
>int</TT
>.</P
><P
>Distinguishing the operator and operand is harder with curried functions.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun f() = 
let
    fun g(a, b) = a + b
in
    foldl g 0.0 [1, 2]
end</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type1b.sml:2.1-6.4 Error: operator and operand don't agree [literal]
  operator domain: real list
  operand:         int list
  in expression:
    ((foldl g) 0.0) (1 :: 2 :: nil)</PRE
></TD
></TR
></TABLE
><P
>Here the operator is the expression <TT
CLASS="COMPUTEROUTPUT"
>(foldl g 0.0)</TT
> which must
take a list of reals for the final argument.  The error is that a list
of integers was supplied.  We can surmise that lists in square brackets
are represented internally in the compiler as applications of the list
constructor operator <TT
CLASS="COMPUTEROUTPUT"
>::</TT
>.</P
><P
>If you leave out a semicolon in a sequence expression you will usually
end up with a type error.  Here's a simple example.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun f x =
let
    val msg = "hello"
in
    print msg
    print "\n"
end</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type1c.sml:2.1-7.4 Error: operator is not a function [tycon mismatch]
  operator: unit
  in expression:
    (print msg) print</PRE
></TD
></TR
></TABLE
><P
>To the compiler it looks like you are passing the <TT
CLASS="COMPUTEROUTPUT"
>print</TT
> function
as an argument to the <TT
CLASS="COMPUTEROUTPUT"
>(print msg)</TT
> expression. But this expression
isn't even a function. Its type is <TT
CLASS="COMPUTEROUTPUT"
>unit</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN6509"
>If and Case Expressions</A
></H2
><P
>Some kinds of expressions don't end up in the error report how they
started out in your code.  Here's a silly example with two calls to the
function <TT
CLASS="COMPUTEROUTPUT"
>g</TT
>.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun f lst = 
(
    if length lst = 1
    then
        g print lst
    else
        g (fn s =&#62; (print s; print "\n")) (*lst*)
)

and g printer lst = app printer lst</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type2a.sml:2.1-8.2 Error: types of rules don't agree [circularity]
  earlier rule(s): bool -&#62; 'Z
  this rule: bool -&#62; 'Y list -&#62; 'Z
  in rule:
    false =&#62; g (fn s =&#62; (&#60;exp&#62;; &#60;exp&#62;))</PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>if</TT
> expression becomes a <TT
CLASS="COMPUTEROUTPUT"
>case</TT
> expression internally so
that <TT
CLASS="COMPUTEROUTPUT"
>(if b then x else y)</TT
> becomes <TT
CLASS="COMPUTEROUTPUT"
>(case b of true =&#62; x |
false =&#62; y)</TT
>.  The source position in the message covers the range of
the lines of the <TT
CLASS="COMPUTEROUTPUT"
>if</TT
> expression.</P
><P
>The two cases are called rules. Each rule is treated like a function
from the type of the case argument (here <TT
CLASS="COMPUTEROUTPUT"
>bool</TT
>) to the type of the
case result (here represented as the unknown type <TT
CLASS="COMPUTEROUTPUT"
>'Z</TT
>).  The type
checker has a problem with the <TT
CLASS="COMPUTEROUTPUT"
>else</TT
> part.  The expression still
needs an extra argument of type <TT
CLASS="COMPUTEROUTPUT"
>'Y list</TT
> before it can return the
case's type.  This is because I forgot the <TT
CLASS="COMPUTEROUTPUT"
>lst</TT
> argument.</P
><P
>The type checker uses the term &quot;object&quot; for the expression after the
case keyword.  Here is an example of a mismatch with the rules.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun process (cmd: string) inp =
(
    case cmd of
      [] =&#62; []

    | (last::rest) =&#62;
        (
            print last;
            app print rest;
            inp
        )
)</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type2b.sml:3.5-11.3 Error: case object and rules don't agree [tycon mismatch]
  rule domain: string list
  object: string
  in expression:
    (case cmd
      of nil =&#62; nil
       | last :: rest =&#62; (print last; (app &#60;exp&#62;) rest; inp))</PRE
></TD
></TR
></TABLE
><P
>The rules clearly want a list of strings but there is an erroneous type
constraint that says that <TT
CLASS="COMPUTEROUTPUT"
>cmd</TT
> must be just a string.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN6532"
>Non-local Type Errors</A
></H2
><P
>Here's an example of a type error that propagates through a couple of
levels of function call.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun run() = print(process "stop")

and process cmd =
(
    case cmd of
      "go" =&#62; go()
    | _    =&#62; stop()
)

and go()   = (3, "done")
and stop() = (4, "stopped")</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type3a.sml:1.1-12.28 Error: right-hand-side of clause doesn't 
agree with function result type [tycon mismatch]
  expression:  int * string
  result type:  string
  in declaration:
    go = (fn () =&#62; (3,"done"))
type3a.sml:1.1-12.28 Error: right-hand-side of clause doesn't 
agree with function result type [tycon mismatch]
  expression:  int * string
  result type:  string
  in declaration:
    stop = (fn () =&#62; (4,"stopped"))</PRE
></TD
></TR
></TABLE
><P
>The expected result type for the <TT
CLASS="COMPUTEROUTPUT"
>go</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>stop</TT
> functions is
determined to be <TT
CLASS="COMPUTEROUTPUT"
>string</TT
> from the call to print in the first line.
The error messages report the entire group of functions that are joined
by the <TT
CLASS="COMPUTEROUTPUT"
>and</TT
> keyword which doesn't localise the error much.
If the <TT
CLASS="COMPUTEROUTPUT"
>run</TT
> function comes last then the error is localised better.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun process cmd =
(
    case cmd of
      "go" =&#62; go()
    | _    =&#62; stop()
)

and go()   = (3, "done")
and stop() = (4, "stopped")

fun run() = print(process "stop")</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type3b.sml:11.13-11.34 Error: operator and operand don't agree [tycon mismatch]
  operator domain: string
  operand:         int * string
  in expression:
    print (process "stop")</PRE
></TD
></TR
></TABLE
><P
>Alternatively you can put a type constraint in a function declaration
to break up the type propagation. This makes it clearer to the compiler
and to anyone reading the code what is expected.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun run() = print(process "stop")

and process cmd: int * string =
(
    case cmd of
      "go" =&#62; go()
    | _    =&#62; stop()
)

and go()   = (3, "done")
and stop() = (4, "stopped")</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type3c.sml:1.13-1.34 Error: operator and operand don't agree [tycon mismatch]
  operator domain: string
  operand:         int * string
  in expression:
    print (process "stop")</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x6465.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="a6548.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Record Errors</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="a6445.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Installation</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
