<HTML
><HEAD
><TITLE
>The SML/NJ Extensions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="Programming with Standard ML"
HREF="p31.html"><LINK
REL="PREVIOUS"
TITLE="The POSIX API"
HREF="x1164.html"><LINK
REL="NEXT"
TITLE="Signals"
HREF="x1452.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x1164.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x1452.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="AEN1357"
>Chapter 4. The SML/NJ Extensions</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="c1357.html#UNSAFEAPI"
>The Unsafe API</A
></DT
><DT
><A
HREF="x1452.html"
>Signals</A
></DT
><DT
><A
HREF="x1503.html"
>The <TT
CLASS="COMPUTEROUTPUT"
>SMLofNJ</TT
> API</A
></DT
><DT
><A
HREF="x1626.html"
>The Socket API</A
></DT
></DL
></DIV
><P
>    These are extensions to the Basis library that are specific to SML/NJ.
    You can find reference documentation to them in the &quot;Special features
    of SML/NJ&quot; page via the SML/NJ home page[<SPAN
CLASS="CITATION"
><A
HREF="b6666.html#BIBE.SML"
><I
>SML</I
></A
></SPAN
>].</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="UNSAFEAPI"
>The Unsafe API</A
></H1
><P
>The Unsafe API is a collection of functions that bypass the normal safety
checks of the language and the Basis library.  These functions are available in the
<TT
CLASS="COMPUTEROUTPUT"
>Unsafe</TT
> structure. It provides:</P
><P
></P
><UL
><LI
><P
>   Access to the elements of arrays and vectors, including strings, without
        the usual subscript range checks.</P
></LI
><LI
><P
>   Access to information about the memory representation of values.</P
></LI
><LI
><P
>   An interface to C functions in the runtime.</P
></LI
><LI
><P
>   Miscellaneous operations used internally by the compiler and associated 
        subsystems.</P
></LI
></UL
><P
>Unchecked subscripting is used internally by the array and vector
functions in the Basis library.  Wherever possible you should design
your code to make use of the Basis functions.  Using the unchecked
operations directly puts your program at risk of crashing.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1376"
>Unsafe Vectors and Arrays</A
></H2
><P
>The following monomorphic vectors and arrays are available.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="COMPUTEROUTPUT"
>Unsafe.CharVector</TT
></DT
><DD
><P
>    This operates on strings, which are vectors of characters.</P
></DD
><DT
><TT
CLASS="COMPUTEROUTPUT"
>Unsafe.Word8Vector</TT
></DT
><DD
><P
>    This operates on vectors of bytes.</P
></DD
><DT
><TT
CLASS="COMPUTEROUTPUT"
>Unsafe.CharArray</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>Unsafe.Word8Array</TT
></DT
><DD
><P
>    These operate on arrays of characters or bytes.</P
></DD
><DT
><TT
CLASS="COMPUTEROUTPUT"
>Unsafe.Real64Array</TT
></DT
><DD
><P
>    This operates on arrays of double precision reals. The C equivalent
    would be the array type <TT
CLASS="COMPUTEROUTPUT"
>double[]</TT
>.<A
NAME="AEN1403"
HREF="#FTN.AEN1403"
>[1]</A
></P
></DD
></DL
></DIV
><P
>These structures conform to one of these two signatures.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>signature UNSAFE_MONO_VECTOR =
  sig

    type vector
    type elem

    val sub : (vector * int) -&#62; elem
    val update : (vector * int * elem) -&#62; unit
    val create : int -&#62; vector

  end

signature UNSAFE_MONO_ARRAY =
  sig

    type array
    type elem

    val sub : (array * int) -&#62; elem
    val update : (array * int * elem) -&#62; unit
    val create : int -&#62; array

  end</PRE
></TD
></TR
></TABLE
><P
>So you can see that you get to update elements of vectors in place just
as you can with arrays.  The <TT
CLASS="COMPUTEROUTPUT"
>create</TT
> functions create a vector or
array of the given length with uninitialised elements.</P
><P
>For arrays and vectors of other kinds of elements there are the
structures <TT
CLASS="COMPUTEROUTPUT"
>Unsafe.Vector</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>Unsafe.Array</TT
> which conform
to the following signatures.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>signature UNSAFE_VECTOR =
  sig

    val sub : ('a vector * int) -&#62; 'a
    val create : (int * 'a list) -&#62; 'a vector

  end

signature UNSAFE_ARRAY =
  sig

    val sub : ('a array * int) -&#62; 'a
    val update : ('a array * int * 'a) -&#62; unit
    val create : (int * 'a) -&#62; 'a array

  end</PRE
></TD
></TR
></TABLE
><P
>The vector <TT
CLASS="COMPUTEROUTPUT"
>create</TT
> function creates a vector from a list.  You have
to supply the length of the list as the first argument.  The array
<TT
CLASS="COMPUTEROUTPUT"
>create</TT
> function creates an array given a length and an initial
value for each element.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1417"
>Memory Representation Information</A
></H2
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>Unsafe.Object</TT
> structure provides some functions for getting
information about the memory representation.  Read the source code in
the <TT
CLASS="COMPUTEROUTPUT"
>boot/Unsafe/object*</TT
> files of the compiler.  You won't find
much use for this in your programs.  The most useful functions look like
being the <TT
CLASS="COMPUTEROUTPUT"
>toWord32</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>toInt32</TT
> functions which can convert a
byte array to a 32 bit integer.  But there isn't enough functionality
here to be useful for serialising values into a wire protocol.
(See <A
HREF="x892.html"
>the section called <I
>Integers</I
> in Chapter 3</A
> for serialising integers).</P
><P
>You could use this structure to estimate the size of objects in memory.
Here is my version of a function to estimate the size of a value,
including pointed-to values.  I've used <TT
CLASS="COMPUTEROUTPUT"
>O</TT
> as an alias for
<TT
CLASS="COMPUTEROUTPUT"
>Unsafe.Object</TT
>.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>(*  Estimate the size of v in 32-bit words.
    Boxed objects have an extra descriptor word
    which also contains the length for vectors
    and arrays.
*)
fun sizeof v =
let
    fun obj_size obj =
    (
        case O.rep obj of
          O.Unboxed =&#62; 1    (* inline 31 bits *)
        | O.Real    =&#62; 1+2

        | O.Pair      =&#62; tup_size obj
        | O.Record    =&#62; tup_size obj
        | O.RealArray =&#62; tup_size obj

        | O.PolyArray =&#62; arr_size obj

        (* includes Word8Vector.vector
           and CharVector.vector
        *)
        | O.ByteVector =&#62; 1 +
            ((size(O.toString obj)+3) div 4)

        (* includes Word8Array.array
           and CharArray.array
        *)
        | O.ByteArray =&#62;  1 +
            ((Array.length(O.toArray obj)+3) div 4)

        | _ =&#62; 2    (* punt for other objects *)
    )

    (*  Count the record plus the size of
        pointed-to objects in the heap.
    *)
    and tup_size obj =
    let
        fun sz obj =
            if O.boxed obj
            then
                1 + (obj_size obj)
            else
                1
    in
        Vector.foldl
            (fn (obj, s) =&#62; s + (sz obj))
            1
            (O.toTuple obj)
    end

    and arr_size obj =
    let
        fun sz obj =
            if O.boxed obj
            then
                1 + (obj_size obj)
            else
                1
    in
        Array.foldl
            (fn (obj, s) =&#62; s + (sz obj))
            1
            (O.toArray obj)
    end
in
    obj_size(O.toObject v)
end</PRE
></TD
></TR
></TABLE
><P
>This is a main function to try it out.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun main(arg0, argv) =
let
    fun show name v = print(concat[
            "Size of ", name,
            " = ", Int.toString(sizeof v),
            " 32-bit words\n"])
in
    show "integer"  3;
    show "real"     3.3;
    show "string"   "abc";

    show "pair"     ("abc", 42);
    show "record"   {a = 1, b = 4.5, c = "fred"};

    OS.Process.success
end</PRE
></TD
></TR
></TABLE
><P
>See <A
HREF="c2882.html#PERFOBJLAYOUT"
>the section called <I
>Heap Object Layout</I
> in Chapter 7</A
> for more information on object layout
in the heap.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1433"
>The C Interface</A
></H2
><P
>The runtime includes a collection of C functions that implement the
low-level Basis operations such as those in the <TT
CLASS="COMPUTEROUTPUT"
>Posix</TT
> structure.
The SML code calls these C functions using the functions in the
<TT
CLASS="COMPUTEROUTPUT"
>Unsafe.CInterface</TT
> structure.  These functions must be specially
written to take arguments in the form of SML values.  This is not a
general purpose interface to C functions.  I only mention it in case
you think that it is for general purpose use.</P
><P
>Later versions of SML/NJ will include a general purpose interface for
calling any C function in a shared library which is loaded at run-time.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1439"
>Miscellaneous Unsafe Operations</A
></H2
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>Unsafe.blastRead</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>Unsafe.blastWrite</TT
> functions
are used to serialise/deserialise entire data structures for writing
to files.  The <TT
CLASS="COMPUTEROUTPUT"
>blastWrite</TT
> function is expensive to run since it
uses the garbage collector to traverse the data structure to locate all
values reachable from the root value.  You shouldn't call it often to
serialise small data structures.  Instead it is intended that you build
up an entire data structure and then dump it into a file at exit time.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>Unsafe.cast</TT
> function can be used to cast a value to any other
type. This of course is very dangerous unless you know the underlying
memory representation.  Most cases where you might want to do this are
already provided for. For example converting between bytes and characters
is provided in the <TT
CLASS="COMPUTEROUTPUT"
>Byte</TT
> structure.</P
><P
>The other functions in <TT
CLASS="COMPUTEROUTPUT"
>Unsafe</TT
> should not be used.  Some are used by
separate systems such as the Concurrent ML library which we will be
using later.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>Unsafe.Poll</TT
> structure is not normally accessible and isn't interesting
to us.</P
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1403"
HREF="c1357.html#AEN1403"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>There should be
    a <TT
CLASS="COMPUTEROUTPUT"
>Unsafe.Real64Vector</TT
> but it isn't implemented yet.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x1164.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x1452.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>The POSIX API</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="p31.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Signals</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
