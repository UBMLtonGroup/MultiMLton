<HTML
><HEAD
><TITLE
>Coroutines</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="Concurrency"
HREF="c2344.html"><LINK
REL="PREVIOUS"
TITLE="Concurrency"
HREF="c2344.html"><LINK
REL="NEXT"
TITLE="The CML Model"
HREF="x2442.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c2344.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 6. Concurrency</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x2442.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="COROUTINES"
>Coroutines</A
></H1
><P
>You are already familiar with the idea of a subroutine.  Control is
transferred to some separate section of code which executes to
completion. Then control is returned back from whence it came.
The separate section of code is subordinate to the calling code, hence
the name subroutine.  Coroutines redefine the relationship between two
sections of code to make them more like peers. <A
HREF="x2405.html#TWOCOROUTINES"
>Figure 6-2</A
>(a)
shows a loop with two coroutines passing control back and forth between
them.</P
><DIV
CLASS="FIGURE"
><A
NAME="TWOCOROUTINES"
></A
><P
><B
>Figure 6-2. Two Coroutines</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><center><IMG
SRC="concur/coroutines.png"
></center></IMG
></P
></DIV
></DIV
><P
>Coroutine 1 consists of two blocks of code, C1a and C1b, similarly for
coroutine 2.  Coroutine 1 transfers control after C1a to coroutine
2 which in this case picks up execution at the beginning of C2b and
continues with C2a and then transfers control back to coroutine 1. When
control is transferred to a coroutine the execution always continues at
the point the coroutine was last at (except the first time it is called
in which case it starts at the top of the coroutine).  You might ask why
not simply include the blocks inline as in <A
HREF="x2405.html#TWOCOROUTINES"
>Figure 6-2</A
>(b).
The answer is the same as for subroutines, a coroutine might be called
from multiple places or, even if called from only one place, the resulting
code can be clearer.</P
><P
>An example of the use of coroutines is to implement the idea of
<I
CLASS="EMPHASIS"
>generators</I
> for loops.  Here is an example (in Perl) of iterating
over a list of names.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>foreach my $k ("tom", "dick", "harry")
{
    print "not for any $k\n";
}</PRE
></TD
></TR
></TABLE
><P
>The list could instead be produced from a function call.  We can talk
about a function that generates a list and a loop that iterates over or
consumes the list.  This Perl example consumes one value from the
list for each iteration.  If we had a function generating the list
it would construct the complete list in memory before the
loop started.  This could consume a lot of memory.  A more efficient
way would be to have the generating function and the consuming loop run
concurrently. The generator generates a value in the list and returns
it to the consumer.  The consumer calls back to the generator for the
next value.  The generator and consumer are running as coroutines.</P
><P
>Some languages have included generators directly as a language feature.
Here is an example from the CLU language [<SPAN
CLASS="CITATION"
><A
HREF="b6666.html#BIBE.CLU"
><I
>CLU</I
></A
></SPAN
>].</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>start_up = proc()
    outstream:stream := primary_output()
    for s:string in get_hello_world() do
        stream$putl(outstream,s)
      end
  end

get_hello_world = iter() yields(string)
    while (true) do
        yield ("Hello, World!")
      end
  end</PRE
></TD
></TR
></TABLE
><P
>In CLU generators are a special type of procedure called an iterator
or <TT
CLASS="COMPUTEROUTPUT"
>iter</TT
>.  The main function <TT
CLASS="COMPUTEROUTPUT"
>start_up()</TT
> has a <TT
CLASS="COMPUTEROUTPUT"
>for</TT
>
loop that iterates the string variable <TT
CLASS="COMPUTEROUTPUT"
>s</TT
> over the stream
of strings produced by the generator <TT
CLASS="COMPUTEROUTPUT"
>get_hello_world()</TT
>.
The generator produces an infinite stream of &quot;hello world&quot; messages.
The <TT
CLASS="COMPUTEROUTPUT"
>yield</TT
> statement transfers control back to the calling loop.
When the calling loop completes an iteration it will transfer control
back to <TT
CLASS="COMPUTEROUTPUT"
>get_hello_world()</TT
> after the <TT
CLASS="COMPUTEROUTPUT"
>yield</TT
> statement and
the <TT
CLASS="COMPUTEROUTPUT"
>while</TT
> loop will go around again.</P
><P
>Coroutines provide a more general mechanism that you can use to implement
patterns like this.</P
><P
>In <A
HREF="c33.html#PUREFPIO"
>the section called <I
>Pure FP and I/O</I
> in Chapter 1</A
> I talked about lazy streams. They are another
example of the producer/consumer relationship. You could implement lazy
streams as coroutines. The compiler for a lazy functional language
could be said to automatically convert functions to coroutines when
there is a producer/consumer relationship.</P
><P
>Finally it is only a small step from coroutines to concurrent tasks.
A set of tasks without pre-emptive scheduling is equivalent to a set of
coroutines.  Each task explicitly transfers control to another through a
<I
CLASS="EMPHASIS"
>yield</I
> operation.  If you add a timer to force the yield periodically
then you have a proper pre-emptively scheduled concurrent system.</P
><P
>CML uses the <TT
CLASS="COMPUTEROUTPUT"
>call/cc</TT
> operation to save the state of a running
thread as a continuation. The continuations of the threads that aren't
running are stored in a queue. When the current thread yields or is
pre-empted a scheduler selects the next continuation from the queue and
calls it to continue the thread.  A timer is used to trigger a schedule of
the current thread or a thread can yield when it performs some concurrent
operation such as stopping to wait for a message.  CML provides modified
Basis library modules so that I/O can be safely preempted.</P
><P
>We can turn our view-point around now and use concurrent threads as a way
to implement coroutines, lazy streams and any other kind of concurrent
producer/consumer relationship.  For example, a generator for a loop
can be implemented as a thread that sends the list values as messages to
a consuming thread.  The generator will block until the consumer takes
the next message.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c2344.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x2442.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Concurrency</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c2344.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>The CML Model</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
