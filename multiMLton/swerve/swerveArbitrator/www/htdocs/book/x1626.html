<HTML
><HEAD
><TITLE
>The Socket API</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="The SML/NJ Extensions"
HREF="c1357.html"><LINK
REL="PREVIOUS"
TITLE="The SMLofNJ API"
HREF="x1503.html"><LINK
REL="NEXT"
TITLE="The Utility Libraries"
HREF="c1812.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x1503.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 4. The SML/NJ Extensions</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c1812.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN1626"
>The Socket API</A
></H1
><P
>There is fairly comprehensive API for socket programming in the compiler's
Basis library.  This is an SML/NJ extension that has gone undocumented
until now as far as I know.  </P
><P
>You can find the source for the API in the boot/Sockets directory of
the compiler source.  Start with the <TT
CLASS="COMPUTEROUTPUT"
>SOCKET</TT
> signature in the
<TT
CLASS="COMPUTEROUTPUT"
>socket-sig.sml</TT
> file.  The actual implementation starts with the
shared material in the <TT
CLASS="COMPUTEROUTPUT"
>PreSock</TT
> structure in the <TT
CLASS="COMPUTEROUTPUT"
>pre-sock.sml</TT
>
file.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="GENERICSOCK"
>The Generic Socket Types</A
></H2
><P
>In the <TT
CLASS="COMPUTEROUTPUT"
>Socket</TT
> structure (with signature <TT
CLASS="COMPUTEROUTPUT"
>SOCKET</TT
>) we have
the following generic types.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type ('af, 'sock) sock
type 'af sock_addr

(* witness types for the socket parameter *)
type dgram
type 'a stream
type passive    (* for passive streams *)
type active     (* for active (connected) streams *)</PRE
></TD
></TR
></TABLE
><P
>The clever thing here is the use of type parameters to distinguish
between different kinds of sockets. This lets the type checker do some
checking of the use of sockets.  Internally a socket is represented by
the following datatype in the <TT
CLASS="COMPUTEROUTPUT"
>PreSock</TT
> structure.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>(* the raw representation of a socket
   (a file descriptor for now) *)
type socket = int
datatype ('af, 'sock) sock = SOCK of socket</PRE
></TD
></TR
></TABLE
><P
>The type just includes the integer file descriptor for the socket.
The type variables are not actually used in the definition of a socket.
They are only a part of the logical framework of the program that is
checked by the type checker at compile time<A
NAME="AEN1644"
HREF="#FTN.AEN1644"
>[1]</A
>.</P
><P
>The first type parameter to <TT
CLASS="COMPUTEROUTPUT"
>sock</TT
> distinguishes the different
address families.  All of the functions in the Socket structure accept a
socket type, such as <TT
CLASS="COMPUTEROUTPUT"
>('a, 'b) sock</TT
>, with any address family, as you
would expect.  Address families are used at the time sockets are created.
See <A
HREF="x1626.html#SIMPLETCPCLIENT"
>the section called <I
>A Simple TCP Client</I
></A
> for an example.  The <TT
CLASS="COMPUTEROUTPUT"
>Socket.AF</TT
>
structure defines a type for address families and some functions to
obtain values of the type.  Normally you would use the specialised types
of <A
HREF="x1626.html#SPECIFICSOCK"
>the section called <I
>The Specific Socket Types</I
></A
>.</P
><P
>The second type parameter <TT
CLASS="COMPUTEROUTPUT"
>'sock</TT
> distinguishes between the
different states of a socket.  The possible types are:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="COMPUTEROUTPUT"
>dgram</TT
> for a datagram (UDP) socket;</P
></LI
><LI
><P
><TT
CLASS="COMPUTEROUTPUT"
>passive stream</TT
> for a stream (TCP) socket that will be
        used to accept a connection but has not yet been connected, and</P
></LI
><LI
><P
><TT
CLASS="COMPUTEROUTPUT"
>active stream</TT
> for a connected stream (TCP) socket.</P
></LI
></UL
><P
>Some functions in <TT
CLASS="COMPUTEROUTPUT"
>Socket</TT
> only operate on passive or active streams.
For example</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val accept: ('a, passive stream) sock -&#62;
            (('a, active stream) sock * 'a sock_addr)

val listen: (('a, passive stream) sock * int) -&#62; unit

val sendVec: (('a, active stream) sock * Word8Vector.vector buf)
             -&#62; int</PRE
></TD
></TR
></TABLE
><P
>The type parameters constrain you to ensure that you cannot call
<TT
CLASS="COMPUTEROUTPUT"
>sendVec</TT
> on the same socket value that you passed to <TT
CLASS="COMPUTEROUTPUT"
>accept</TT
>
or <TT
CLASS="COMPUTEROUTPUT"
>listen</TT
>.  You can however call <TT
CLASS="COMPUTEROUTPUT"
>sendVec</TT
> on the value
returned from <TT
CLASS="COMPUTEROUTPUT"
>accept</TT
>.</P
><P
>Socket addresses are defined in <TT
CLASS="COMPUTEROUTPUT"
>Socket</TT
> as being generic over
address families. But you will use more specific types with their own
functions for addresses in a specific family.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SPECIFICSOCK"
>The Specific Socket Types</A
></H2
><P
>The socket types in <A
HREF="x1626.html#GENERICSOCK"
>the section called <I
>The Generic Socket Types</I
></A
> are generic over the
address family.  What you will actually use are sets of socket types
with the address family fixed.  For example the <TT
CLASS="COMPUTEROUTPUT"
>INetSock</TT
> structure
defines a type of socket with the address family fixed at <TT
CLASS="COMPUTEROUTPUT"
>AF_INET</TT
>
for the internet protocols.  The new types and values are:</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>datatype inet = INET

type 'a sock = (inet, 'a) Socket.sock
type 'a stream_sock = 'a Socket.stream sock
type dgram_sock = Socket.dgram sock

type sock_addr = inet Socket.sock_addr</PRE
></TD
></TR
></TABLE
><P
>Here a distinct type called <TT
CLASS="COMPUTEROUTPUT"
>inet</TT
> has been defined, although it
contains no data.  Because it is defined with a datatype it is guaranteed
to be different from any other type.  This allows the type checker to
ensure that you don't mix up sockets with different address families.
The remaining types are specialisations for the <TT
CLASS="COMPUTEROUTPUT"
>inet</TT
> family.
The type variable in the <TT
CLASS="COMPUTEROUTPUT"
>stream_sock</TT
> type will range over the
types <TT
CLASS="COMPUTEROUTPUT"
>passive</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>active</TT
> in the <TT
CLASS="COMPUTEROUTPUT"
>Socket</TT
> structure.</P
><P
>The value <TT
CLASS="COMPUTEROUTPUT"
>INetSock.inetAF</TT
> is an address family value, of type
<TT
CLASS="COMPUTEROUTPUT"
>Socket.AF.addr_family</TT
>, should you need to specify the family
explicitly.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>UnixSock</TT
> structure provides types equivalent to those in
<TT
CLASS="COMPUTEROUTPUT"
>INetSock</TT
> but with the address family fixed for Unix domain sockets.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SOCKADDRESS"
>Socket Addresses</A
></H2
><P
>The type <TT
CLASS="COMPUTEROUTPUT"
>sock_addr</TT
> represents an address that you can bind a socket
to. The generic address, <TT
CLASS="COMPUTEROUTPUT"
>Socket.sock_addr</TT
>, is parameterised by
the address family.  If you look in the <TT
CLASS="COMPUTEROUTPUT"
>PreSock</TT
> structure you
will see that a socket address is represented internally by a byte vector.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type addr = Word8Vector.vector
datatype 'af sock_addr = ADDR of addr</PRE
></TD
></TR
></TABLE
><P
>For each particular address family there is a specialised address type.
For example in the <TT
CLASS="COMPUTEROUTPUT"
>INetSock</TT
> structure there is:</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>datatype inet = INET
type sock_addr = inet Socket.sock_addr

val toAddr   : (NetHostDB.in_addr * int) -&#62; sock_addr
val fromAddr : sock_addr -&#62; (NetHostDB.in_addr * int)
val any  : int -&#62; sock_addr</PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>toAddr</TT
> function will coerce an internet address and a port
number to a socket address which is specialised for the <TT
CLASS="COMPUTEROUTPUT"
>inet</TT
>
address family. The <TT
CLASS="COMPUTEROUTPUT"
>fromAddr</TT
> function will do the reverse.  The any
function uses the <TT
CLASS="COMPUTEROUTPUT"
>0.0.0.0</TT
> internet address (the traditional
<TT
CLASS="COMPUTEROUTPUT"
>INADDR_ANY</TT
>) that you bind a server socket to if you want it
to accept connections from any source address.  Its argument is the
port number.</P
><P
>To lookup an internet address you use the functions in the
<TT
CLASS="COMPUTEROUTPUT"
>NetHostDB</TT
> structure.  These provide the equivalent of the C
library's <TT
CLASS="COMPUTEROUTPUT"
>gethostbyname</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>gethostbyvalue</TT
> functions.
The signature for this structure is:</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>signature NET_HOST_DB =
sig
    eqtype in_addr
    eqtype addr_family
    type entry
    val name     : entry -&#62; string
    val aliases  : entry -&#62; string list
    val addrType : entry -&#62; addr_family
    val addr     : entry -&#62; in_addr
    val addrs    : entry -&#62; in_addr list
    val getByName    : string -&#62; entry option
    val getByAddr    : in_addr -&#62; entry option

    val getHostName : unit -&#62; string

    val scan       : (char, 'a) StringCvt.reader -&#62;
                     (in_addr, 'a) StringCvt.reader
    val fromString : string -&#62; in_addr option
    val toString   : in_addr -&#62; string
end</PRE
></TD
></TR
></TABLE
><P
>You use the <TT
CLASS="COMPUTEROUTPUT"
>getByName</TT
> or <TT
CLASS="COMPUTEROUTPUT"
>getByAddr</TT
> functions to fetch a
database entry, equivalent to C's <TT
CLASS="COMPUTEROUTPUT"
>struct hostent</TT
>.  They return
NONE if the entry is not found. The functions <TT
CLASS="COMPUTEROUTPUT"
>name</TT
> through to
<TT
CLASS="COMPUTEROUTPUT"
>addrs</TT
> fetch the fields of an entry.  The <TT
CLASS="COMPUTEROUTPUT"
>fromString</TT
> function
will parse an address in the numeric formats <I
CLASS="EMPHASIS"
>a.b.c.d</I
>, <I
CLASS="EMPHASIS"
>a.b.c</I
>,
<I
CLASS="EMPHASIS"
>a.b</I
> or <I
CLASS="EMPHASIS"
>a</I
>. Where there is more than one digit the left digits
are 8 bit values and the last digit takes up the rest of the address. Hex
numbers are allowed with a <TT
CLASS="COMPUTEROUTPUT"
>0x</TT
> prefix, octal with a <TT
CLASS="COMPUTEROUTPUT"
>0</TT
> prefix.</P
><P
>For the Unix address family you have in the <TT
CLASS="COMPUTEROUTPUT"
>UnixSock</TT
> structure:</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>datatype unix = UNIX
type sock_addr = unix Socket.sock_addr

val toAddr   : string -&#62; sock_addr
val fromAddr : sock_addr -&#62; string</PRE
></TD
></TR
></TABLE
><P
>The string is the path to the socket in the file system.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SIMPLETCPCLIENT"
>A Simple TCP Client</A
></H2
><P
>This example program makes a TCP connection to a port and fetches one
line of response and prints it.  You can test it against a server such
as the SMTP mail server on port 25 or the NNTP server on port 119. Here is the central
function.  It's fairly straightforward.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun connect port =
let
    val localhost =
            valOf(NetHostDB.fromString "127.0.0.1")
    val addr = INetSock.toAddr(localhost, port)
    val sock = INetSock.TCP.socket()

    fun call sock =
    let
        val _    = Socket.connect(sock, addr)
        val msg  = Socket.recvVec(sock, 1000)
        val text = Byte.bytesToString msg
    in
        print text;
        Socket.close sock
    end
    handle x =&#62; (Socket.close sock; raise x)
in
    call sock
end
handle OS.SysErr (msg, _) =&#62; raise Fail (msg ^ "\n")</PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>recvVec</TT
> function performs the C library <TT
CLASS="COMPUTEROUTPUT"
>recv()</TT
> on
the socket into a buffer of 1000 bytes.  Since we are expecting a text
response the <TT
CLASS="COMPUTEROUTPUT"
>bytesToString</TT
> coerces the byte vector into a text
string.  I've wrapped the connection phase into a function to make it
easier to wrap an exception handler around it.  The handler closes the
socket and reraises the exception.  This is overkill for such a simple
program but it shows you what you would need to do in a larger program.
All errors from the socket functions raise <TT
CLASS="COMPUTEROUTPUT"
>OS.SysErr</TT
> exceptions. The
exception handler for these translates them into a simpler error message.</P
><P
>Here is the main program to call the <TT
CLASS="COMPUTEROUTPUT"
>connect</TT
> function. </P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun toErr msg = TextIO.output(TextIO.stdErr, msg)

fun main(arg0, argv) =
let
in
    case argv of
      [port] =&#62; 
        (case Int.fromString port of
          NONE =&#62; raise Fail "Invalid port number\n"

        | SOME p =&#62; connect p)

    | _ =&#62; raise Fail "Usage: simpletcp port\n";

    OS.Process.success
end
handle
  Fail msg =&#62; (toErr msg; OS.Process.failure)

| x =&#62;
(
    toErr(concat["Uncaught exception: ",
                 exnMessage x, " from\n"]);
    app (fn s =&#62; (print "\t"; print s; print "\n"))
        (SMLofNJ.exnHistory x);
    OS.Process.failure
)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SIMPLETCPSERVER"
>A Simple TCP Server</A
></H2
><P
>This example program complements the simple client of the previous
section.  It listens on a TCP socket and sends a simple text response
to each client that connects.  It is a single threaded server.  Here is
the <TT
CLASS="COMPUTEROUTPUT"
>serve</TT
> function that runs the server.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun serve port =
let
    fun run listener =
    let
        fun accept() =
        let
            val (conn, conn_addr) = Socket.accept listener
        in
            respond conn;
            accept()
        end

        and respond conn =
        let
            val msg = "hello world from tcpserver\n"
            val buf = {buf = Byte.stringToBytes msg,
                       i = 0, sz = NONE}
        in
            ignore(Socket.sendVec(conn, buf));
            Socket.close conn
        end
        handle x =&#62; (Socket.close conn; raise x)

    in
        Socket.Ctl.setREUSEADDR(listener, true);
        Socket.bind(listener, INetSock.any port);
        Socket.listen(listener, 9);
        accept()
    end
    handle x =&#62; (Socket.close listener; raise x)
in
    run (INetSock.TCP.socket())
end
handle OS.SysErr (msg, _) =&#62; raise Fail (msg ^ "\n")</PRE
></TD
></TR
></TABLE
><P
>Again I have used functions to isolate the scope of exception handlers
as well as to implement the server loop.  The <TT
CLASS="COMPUTEROUTPUT"
>run</TT
> function
sets up the socket to listen for connections and runs a loop to accept
each one.  The socket is bound to a given port but its address is set to
<TT
CLASS="COMPUTEROUTPUT"
>0.0.0.0</TT
> (<TT
CLASS="COMPUTEROUTPUT"
>INADDR_ANY</TT
>) to accept from any host.  The <TT
CLASS="COMPUTEROUTPUT"
>listen</TT
>
function takes an integer backlog parameter, the same as the C
library <TT
CLASS="COMPUTEROUTPUT"
>listen()</TT
> function.</P
><P
>Each accepted connection returns a new socket, called <TT
CLASS="COMPUTEROUTPUT"
>conn</TT
>, and
the address of the connecting peer which I ignore.  The <TT
CLASS="COMPUTEROUTPUT"
>respond</TT
>
function builds a buffer to send to the client.  The <TT
CLASS="COMPUTEROUTPUT"
>sendVec</TT
> function
performs the C library <TT
CLASS="COMPUTEROUTPUT"
>send()</TT
> function and returns its result which
will be the number of bytes successfully sent.  In this simple server I
ignore this.  If there is actually an error then the <TT
CLASS="COMPUTEROUTPUT"
>OS.SysErr</TT
>
exception will be raised.  The buffer argument to <TT
CLASS="COMPUTEROUTPUT"
>sendVec</TT
> must
be a record with this type:</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type 'a buf = {buf : 'a, i : int, sz : int option}

val sendVec: (('a, active stream) sock * Word8Vector.vector buf)
             -&#62; int</PRE
></TD
></TR
></TABLE
><P
>The type variable <TT
CLASS="COMPUTEROUTPUT"
>'a</TT
> will be either a vector or an array of bytes
depending on the function you use.  The signature of the <TT
CLASS="COMPUTEROUTPUT"
>sendVec</TT
>
function is shown.  The <TT
CLASS="COMPUTEROUTPUT"
>i</TT
> field is the offset into the buffer
where the send is to start.  The <TT
CLASS="COMPUTEROUTPUT"
>sz</TT
> field is the optional length
of the data to send.  If it is <TT
CLASS="COMPUTEROUTPUT"
>NONE</TT
> then the data extends to the
end of the buffer.  The standard <TT
CLASS="COMPUTEROUTPUT"
>Subscript</TT
> exception is raised
if the offset and length don't fit into the buffer.</P
><P
>The main function for this program is almost identical to the client. It
just gets a port number from the command line.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="MULTISERVER"
>Servers with Multiple Connections</A
></H2
><P
>If you want to write a server to handle multiple connections then you can
either write it in a single-threaded manner using the poll functions in
the <TT
CLASS="COMPUTEROUTPUT"
>OS.IO</TT
> structure or you can use the Concurrent ML library for a more
multi-threaded style.</P
><P
>To use polling you will need the <TT
CLASS="COMPUTEROUTPUT"
>Socket.pollDesc</TT
> function:</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val pollDesc : ('a, 'b) sock -&#62; OS.IO.poll_desc</PRE
></TD
></TR
></TABLE
><P
>This will obtain a descriptor from the socket suitable for use with
<TT
CLASS="COMPUTEROUTPUT"
>OS.IO</TT
>.  Here is some example code for polling a set of sockets
for reading or writing.  </P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type ServerSock = Socket.active INetSock.stream_sock

datatype Handler = Handler of {
        socket: ServerSock,
        reader: ServerSock -&#62; unit,
        writer: ServerSock -&#62; unit
        }

fun poll (handlers: Handler list) =
let
    (*  Convert to a list annotated with iodesc. *)
    fun to_iodesc (Handler {socket, reader, writer}) = 
        (OS.IO.pollToIODesc(Socket.pollDesc socket),
            socket, reader, writer)

    val with_iodesc = map to_iodesc handlers

    (*  Generate a list of poll descriptors for reading
        and writing.
    *)
    fun to_poll (Handler {socket, ...}) = 
            (OS.IO.pollIn o OS.IO.pollOut o Socket.pollDesc)
            socket

    (*  Search for the matching handlers. *)
    fun check_info poll_info =
    let
        val info_iodesc = OS.IO.pollToIODesc(
                                OS.IO.infoToPollDesc poll_info)
        val handler = List.find
                      (fn arg =&#62; (#1 arg) = info_iodesc)
                      with_iodesc
    in
        case handler of
          NONE =&#62; raise Fail "polled a non-existent socket!"

        | SOME (iodesc, socket, reader, writer) =&#62;
        (
            if OS.IO.isIn  poll_info then reader socket else ();
            if OS.IO.isOut poll_info then writer socket else ()
        )
    end

    val info_list = OS.IO.poll(map to_poll handlers, NONE)
in
    app check_info info_list
end</PRE
></TD
></TR
></TABLE
><P
>I've defined a record type for a handler that maps a socket to reader and
writer functions. These functions will be called when the socket is ready
for reading or writing respectively.  My <TT
CLASS="COMPUTEROUTPUT"
>poll</TT
> function takes a
list of handlers and calls the readers and writers for each socket that
is ready for I/O.  The first step is to extend the handler data with
an <TT
CLASS="COMPUTEROUTPUT"
>OS.IO.iodesc</TT
> value.  This is the only type of value used in
<TT
CLASS="COMPUTEROUTPUT"
>OS.IO</TT
> that supports the equality operator so that I can use it
for looking up the handler.  The <TT
CLASS="COMPUTEROUTPUT"
>Socket</TT
> structure only provides
for producing an <TT
CLASS="COMPUTEROUTPUT"
>OS.IO.poll_desc</TT
> which I have to back-convert to
an <TT
CLASS="COMPUTEROUTPUT"
>iodesc</TT
>.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>to_poll</TT
> function separately converts each socket to a
<TT
CLASS="COMPUTEROUTPUT"
>OS.IO.poll_desc</TT
> type.  The <TT
CLASS="COMPUTEROUTPUT"
>pollIn</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>pollOut</TT
> mark
the descriptor for polling for input and output respectively.  I then
pass the descriptors to the <TT
CLASS="COMPUTEROUTPUT"
>OS.IO.poll</TT
> function to get the list of
resulting info records in <TT
CLASS="COMPUTEROUTPUT"
>info_list</TT
>.  I'm not using a timeout here.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>check_info</TT
> function examines each info record. First I
extract the <TT
CLASS="COMPUTEROUTPUT"
>iodesc</TT
> from the info record. Then I search the
<TT
CLASS="COMPUTEROUTPUT"
>with_iodesc</TT
> list for a record with the same <TT
CLASS="COMPUTEROUTPUT"
>iodesc</TT
>. The
argument to the predicate is an annotated tuple. I use
the <TT
CLASS="COMPUTEROUTPUT"
>#1</TT
> notation to get the first member of the tuple which is
the <TT
CLASS="COMPUTEROUTPUT"
>iodesc</TT
>.  The <TT
CLASS="COMPUTEROUTPUT"
>isIn</TT
> function tests if the info record
indicates a socket ready for reading.  If so then I call the reader.
Similarly for the writer.</P
><P
>Here is part of the modified <TT
CLASS="COMPUTEROUTPUT"
>serve</TT
> function from the server in
<A
HREF="x1626.html#SIMPLETCPSERVER"
>the section called <I
>A Simple TCP Server</I
></A
>.  It's just a trivial example of calling
the poll function.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun serve port =
let
    fun run listener =
    let
        fun accept() =
        let
            val (conn, conn_addr) = Socket.accept listener
        in
            poll [Handler {
                    socket = conn,
                    reader = reader,
                    writer = writer
                    }];
            accept()
        end

        and writer conn =
        let
            val msg = "hello world from tcpserver\n"
            val buf = {
                    buf = Byte.stringToBytes msg,
                    i = 0,
                    sz = NONE
                    }
        in
            print "responding to a client\n";
            ignore(Socket.sendVec(conn, buf));
            Socket.close conn
        end
        handle x =&#62; (Socket.close conn; raise x)

        and reader conn = ()</PRE
></TD
></TR
></TABLE
><P
>A serious server would need to maintain a data structure of current
connections. This might be a list of records similar to <TT
CLASS="COMPUTEROUTPUT"
>Handler</TT
>.
However you will get a nicer result if you use Concurrent ML to write
the server in a multi-threaded style.  This will have a reader and a
writer thread for each connection.  See <A
HREF="c2344.html"
>Chapter 6</A
>.</P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1644"
HREF="x1626.html#AEN1644"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>I've corrected
the order of the type variables which is a typo in <TT
CLASS="COMPUTEROUTPUT"
>PreSock.sock</TT
>
that has no effect.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x1503.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c1812.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>The <TT
CLASS="COMPUTEROUTPUT"
>SMLofNJ</TT
> API</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c1357.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>The Utility Libraries</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
