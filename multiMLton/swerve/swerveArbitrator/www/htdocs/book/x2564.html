<HTML
><HEAD
><TITLE
>A Counter Object</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="Concurrency"
HREF="c2344.html"><LINK
REL="PREVIOUS"
TITLE="The CML Model"
HREF="x2442.html"><LINK
REL="NEXT"
TITLE="Some Tips on Using CML"
HREF="x2608.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x2442.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 6. Concurrency</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x2608.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="COUNTEROBJECT"
>A Counter Object</A
></H1
><P
>This section shows a simple example of two threads sending a message.
One thread will implement a counter object that increments its value in
response to commands. For the body of the object I use this <TT
CLASS="COMPUTEROUTPUT"
>counter</TT
> function.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>datatype Message = 
        MsgIsIncr of int
    |   MsgIsStop

fun counter in_chan () =
let
    fun loop count =
    (
        case CML.recv in_chan of
          MsgIsIncr n =&#62; loop (count + n)

        | MsgIsStop =&#62;
        (
            print(concat["Count is ", Int.toString count, "\n"])
        )
    )
in
    loop 0
end</PRE
></TD
></TR
></TABLE
><P
>The possible messages are defined by the <TT
CLASS="COMPUTEROUTPUT"
>Message</TT
> datatype.
The <TT
CLASS="COMPUTEROUTPUT"
>counter</TT
> function contains a loop implementing a state machine.
The state variable is the count with an initial value of 0.  When the
counter is stopped it just prints its count.  The channel is passed in
via the <TT
CLASS="COMPUTEROUTPUT"
>in_chan</TT
> argument when the function is started.</P
><P
>The client of the object is a thread running this driver function which
sends some messages and stops.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun driver out_chan () =
let
in
    CML.send(out_chan, MsgIsIncr 3);
    CML.send(out_chan, MsgIsIncr ~1);
    CML.send(out_chan, MsgIsStop)
end</PRE
></TD
></TR
></TABLE
><P
>The main thread of the program is this function called <TT
CLASS="COMPUTEROUTPUT"
>run</TT
>.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun run() =
let
    val chan: Message CML.chan = CML.channel()
    val d = CML.spawn (driver chan)
    val c = CML.spawn (counter chan)
in
    CML.sync(CML.joinEvt d);
    CML.sync(CML.joinEvt c);
    ()
end</PRE
></TD
></TR
></TABLE
><P
>I first create a channel which passes <TT
CLASS="COMPUTEROUTPUT"
>Message</TT
> values.  I've used an
explicit type constraint to make this clear but type inference would have
figured it out if I didn't.  Then I spawn two threads for the counter
and its driver.  The channel is passed to each thread via the curried
arguments <TT
CLASS="COMPUTEROUTPUT"
>in_chan</TT
> or <TT
CLASS="COMPUTEROUTPUT"
>out_chan</TT
>.  (Because of the <TT
CLASS="COMPUTEROUTPUT"
>()</TT
>
argument in the function definitions, the expression <TT
CLASS="COMPUTEROUTPUT"
>(driver chan)</TT
>
is a function taking <TT
CLASS="COMPUTEROUTPUT"
>unit</TT
> as its argument, which matches the
requirement of the <TT
CLASS="COMPUTEROUTPUT"
>CML.spawn</TT
> function.)  Then I wait for each
thread to terminate.  The <TT
CLASS="COMPUTEROUTPUT"
>joinEvt</TT
> function returns an event that
is enabled when the thread terminates.  The call to <TT
CLASS="COMPUTEROUTPUT"
>sync</TT
> performs
the wait.</P
><P
>A thread terminates when its function returns or it explicitly calls
<TT
CLASS="COMPUTEROUTPUT"
>CML.exit</TT
>.  Thread functions always return <TT
CLASS="COMPUTEROUTPUT"
>unit</TT
> and so does
the join event so there is no mechanism for a thread to return a
value when it terminates unless it sends one through a channel (or does
something ugly like write to a global variable).</P
><P
>I don't actually need to do the wait in the <TT
CLASS="COMPUTEROUTPUT"
>run</TT
> function.  If I
don't then the function will return and its thread will terminate but
the spawned threads will continue.  The program won't terminate until
all of its threads have terminated.</P
><P
>Here is the main function.  To start the main thread I need to explicitly
call <TT
CLASS="COMPUTEROUTPUT"
>RunCML.doit</TT
> which is a (currently) undocumented function.
The second argument is an optional time interval for scheduling which
defaults to 20 milliseconds.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun main(arg0, argv) =
let
in
    RunCML.doit(run, NONE);
    OS.Process.success
end</PRE
></TD
></TR
></TABLE
><P
>The CM file for this program is as follows. It picks up the CML package
containing the <TT
CLASS="COMPUTEROUTPUT"
>CML</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>SyncVar</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>Mailbox</TT
>, and modified
I/O structures.  </P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>group is 
    counter.sml
    /src/smlnj/current/lib/cml.cm
    /src/smlnj/current/lib/cml-lib.cm</PRE
></TD
></TR
></TABLE
><P
>You can terminate the program early by calling <TT
CLASS="COMPUTEROUTPUT"
>RunCML.shutdown</TT
>
with an exit status. This will cause the <TT
CLASS="COMPUTEROUTPUT"
>RunCML.doit</TT
> function to
return early with the status value.  For example</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>RunCML.shutdown OS.Process.failure</PRE
></TD
></TR
></TABLE
><P
>In this case you would call <TT
CLASS="COMPUTEROUTPUT"
>RunCML.shutdown</TT
> with a success status
for normal exit.  For example</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun run() =
let
    ...
in
    ...
    RunCML.shutdown OS.Process.success
end

fun main(arg0, argv) =
(
    RunCML.doit(run, NONE)
)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x2442.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x2608.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>The CML Model</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c2344.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Some Tips on Using CML</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
