<HTML
><HEAD
><TITLE
>The IETF Layer</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="The Swerve Detailed Design"
HREF="c4671.html"><LINK
REL="PREVIOUS"
TITLE="The Store Layer"
HREF="x5210.html"><LINK
REL="NEXT"
TITLE="The Config Layer"
HREF="x5681.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x5210.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. The Swerve Detailed Design</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x5681.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN5496"
>The IETF Layer</A
></H1
><P
>This layer implements modules that deal with the kinds of data that
make up internet protocol messages (as described in the RFCs).  For the
purposes of HTTP, this includes headers, status messages and mime-encoded
entities.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DTLENTITY"
>The Entity Module</A
></H2
><P
>This module implements the <TT
CLASS="COMPUTEROUTPUT"
>Entity</TT
> type for all HTML pages,
images etc. that are transferred over HTTP.  It also includes a
simple bit of MIME type handling.  The functions for transferring
entities around the server are in here. This includes the transfer
protocol (the <TT
CLASS="COMPUTEROUTPUT"
>XferProto</TT
> type) and the producer/consumer system.
See <A
HREF="x3709.html#ENTITYDESIGN"
>the section called <I
>Entities, Producers and Consumers</I
> in Chapter 8</A
> for an overview.</P
><P
>First here is the MIME type interface. </P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>datatype MType =
        MType of {
            mtype:      string,
            msubtype:   string,
            mparams:    (string * string) list
            }

    |   MTypeUnknown

val formatType:     MType -&#62; TextFrag.Text

(*  This creates a simple type e.g. text/plain.
*)
val simpleType:     string -&#62; string -&#62; MType

(*  This works out a Mime type for a file. It only
    looks at the file name.
*)
val getMimeType:    string -&#62; MType</PRE
></TD
></TR
></TABLE
><P
>This just declares the type and provides some utility functions.
The declaration is needed here for the entity info. The parsing of
MIME types in headers is taken care of in the HTTPHeader module
(see <A
HREF="x5496.html#DTLHEADER"
>the section called <I
>The HTTPHeader Module</I
></A
>).  The <TT
CLASS="COMPUTEROUTPUT"
>formatType</TT
> function
converts the type back to the text format suitable for a header.
The <TT
CLASS="COMPUTEROUTPUT"
>getMimeType</TT
> function maps the file name extension to a
MIME type using the types file specified by the <TT
CLASS="COMPUTEROUTPUT"
>TypesConfig</TT
>
configuration parameter (see <A
HREF="x3464.html#SERVERPARAMS"
>the section called <I
>The Server Parameters</I
> in Chapter 8</A
>).  Most of the
work for this is done in the Config module in <A
HREF="x5681.html#DTLCONFIG"
>the section called <I
>The Config Module - Interface</I
></A
>.
These functions are simple enough to not need further explanation here.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>Encoding</TT
> type is treated similarly to <TT
CLASS="COMPUTEROUTPUT"
>MType</TT
> above. The
parsing of encodings is done in the HTTPHeader module. The type is
declared here for the entity info. The <TT
CLASS="COMPUTEROUTPUT"
>formatEncoding</TT
> encoding
function converts an encoding value back to the text format for a
header. I won't discuss if further here. The server never takes notice
of the encoding. Entities passing through are never decoded. When the
server has to generate an entity such as a message or a fancy index for
a directory they are never encoded. I don't recognise compression in
disk files.</P
><P
>As explained in <A
HREF="x3709.html#ENTITYDESIGN"
>the section called <I
>Entities, Producers and Consumers</I
> in Chapter 8</A
> the interface for an entity
is abstract. The data is delivered by a producer function. The entity body
itself is represented by a function that can create a producer function.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>datatype Entity =
        Entity of {
            info:   Info,
            body:   MKProducer
            }
    |   None

and Info = Info of {
        etype:      MType option,
        encoding:   Encoding option,
        length:     int option,
        last_mod:   Date.date option
        }</PRE
></TD
></TR
></TABLE
><P
>The Info type contains information about the entity. This corresponds to
the <TT
CLASS="COMPUTEROUTPUT"
>Content-Type</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>Content-Encoding</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>Content-Length</TT
>
and <TT
CLASS="COMPUTEROUTPUT"
>Last-Modified</TT
> HTTP headers.  Not all of the Info fields are
used by all of the different kinds of producer function. For example if
the entity is stored in a disk file then the length and last modification
date are taken from the file instead of the Info.  The MIME type is
derived from the file name extension but the encoding is ignored.
I should either look at the extension or try to detect the type of the
file from the first few bytes.  But ignoring the encoding will be enough
for this simple server at the moment.</P
><P
>Here are the interface declarations for the transfer protocol
and producer/consumer system.  The protocol is described in more detail in
<A
HREF="x3709.html#ENTITYDESIGN"
>the section called <I
>Entities, Producers and Consumers</I
> in Chapter 8</A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>(*  A producer sends messages of this type to its consumer. *)
and XferProto = 
        XferInfo  of Info               (* send this first *)
    |   XferBytes of Word8Vector.vector (* then lots of these *)
    |   XferDone                        (* then one of these *)
    |   XferAbort                       (* or else one of these *)
withtype Consumer = XferProto CML.chan
     and MKProducer = Abort.Abort -&#62; Info -&#62; Consumer -&#62; CML.thread_id

(*  This creates a producer for an entity. *)
val startProducer:  Abort.Abort -&#62; Entity -&#62; Consumer -&#62; CML.thread_id</PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val textProducer:   TextFrag.Text -&#62; MKProducer
val tmpProducer:    TmpFile.TmpFile -&#62; MKProducer
val fileProducer:   string -&#62; MKProducer

(*  Beware that process producers are one-shot. 
    The holder is closed after the entity has been produced.
*)
val procProducer:   ExecReader.Holder -&#62; MKProducer</PRE
></TD
></TR
></TABLE
><P
>To create an <TT
CLASS="COMPUTEROUTPUT"
>Entity</TT
> value which represents a disk file you would
use the <TT
CLASS="COMPUTEROUTPUT"
>fileProducer</TT
> function.  This returns a <TT
CLASS="COMPUTEROUTPUT"
>MKProducer</TT
>
function which in turn can be used to make multiple concurrent producers.
Each producer delivers the contents of the file using the transfer
protocol.  </P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>startProducer</TT
> function starts the delivery process.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>and startProducer abort (Entity {info, body}) consumer = body abort info consumer

|   startProducer abort None consumer =
(
    CML.spawn (fn () =&#62; CML.send(consumer, XferDone))
)</PRE
></TD
></TR
></TABLE
><P
>All it does is call the producer function. It handles the case of a
non-existent entity by starting a producer thread that just sends the
<TT
CLASS="COMPUTEROUTPUT"
>XferDone</TT
> message.</P
><P
>Here is the <TT
CLASS="COMPUTEROUTPUT"
>fileProducer</TT
> function.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>and fileProducer name abort old_info consumer =
let
    fun producer() =
    let
        (*  All of the info fields are regenerated from the
            file at the time we send it.
        *)
        val opt_len = FileIO.fileSize name
        val modt = Option.map Date.fromTimeUniv (FileIO.modTime name)

        val info = Info {
                    etype       = SOME(getMimeType name),
                    encoding    = NONE,
                    length      = opt_len,
                    last_mod    = modt
                    }
    in
        CML.send(consumer, XferInfo info);

        case opt_len of     (* NONE if can't access the file *)
          NONE     =&#62; CML.send(consumer, XferDone)
        | SOME len =&#62; send_file()
    end


    and send_file() =
    let
        (*  Record the open file so that it can be finalised if
            the consumer is aborted e.g. due to a connection timeout.
        *)
        fun loop strm =
        (
            if Abort.aborted abort
            then
                CML.send(consumer, XferAbort)
            else
            let
                val chunk = BinIO.inputN(strm, file_chunk)
            in
                if Word8Vector.length chunk = 0
                then
                    CML.send(consumer, XferDone)
                else
                (
                    CML.send(consumer, XferBytes chunk);
                    loop strm
                )
            end
        )
    in
        case BinIOReader.openIt abort name of
          NONE   =&#62; ()
        | SOME h =&#62; (loop (BinIOReader.get h); BinIOReader.closeIt h)
    end
    handle x =&#62; (Log.logExn x; ())

in
    CML.spawn producer
end</PRE
></TD
></TR
></TABLE
><P
>I am using currying here.  The function call <TT
CLASS="COMPUTEROUTPUT"
>(fileProducer
&quot;foo.html&quot;)</TT
> returns a function that takes abort, Info and consumer
arguments and starts the producer thread and returns its id.  This
returned function has the type <TT
CLASS="COMPUTEROUTPUT"
>MkProducer</TT
>.  When all of the
arguments to the <TT
CLASS="COMPUTEROUTPUT"
>fileProducer</TT
> function are eventually supplied it
spawns a thread which runs its <TT
CLASS="COMPUTEROUTPUT"
>producer</TT
> function. New entity info
is derived from the file each time that a producer thread is spawned. This
allows changes to the file length and modification time to be noticed.
There is no safety check for a file changing as it is being delivered.
If this happens then the <TT
CLASS="COMPUTEROUTPUT"
>Content-Length</TT
> header won't match the
amount of data actually sent.</P
><P
>If the file is of non-zero length then its contents are sent by the
<TT
CLASS="COMPUTEROUTPUT"
>send_file</TT
> function.  This does some binary I/O to read the file in
chunks and deliver them in <TT
CLASS="COMPUTEROUTPUT"
>XferBytes</TT
> messages.  The BinIOReader
module takes care of waiting for free file descriptors and closing the
file on an abort. (See <A
HREF="x5914.html#OPENFILEMGR"
>the section called <I
>The Open File Manager</I
></A
>).  I also need to check
for the abort condition while sending the file. The CML library has no
function like &quot;<TT
CLASS="COMPUTEROUTPUT"
>inputNEvt</TT
>&quot; which returns an event for when data
is ready from a <TT
CLASS="COMPUTEROUTPUT"
>BinIO.instream</TT
>.  I have to poll for the abort
condition before each file read.  This is a case where the server may
end up trying to send data to an aborted connection.  This will be caught
when an attempt is made to write to a closed connection socket.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>tmpProducer</TT
> delivers from a temporary file. This is just a
particular case of the <TT
CLASS="COMPUTEROUTPUT"
>fileProducer</TT
>.  The <TT
CLASS="COMPUTEROUTPUT"
>textProducer</TT
>
delivers from a <TT
CLASS="COMPUTEROUTPUT"
>TextFrag</TT
> in memory.  The length is obtained from
the length of the text and the other Info must be supplied. Each fragment
of the text is sent as a separate <TT
CLASS="COMPUTEROUTPUT"
>XferBytes</TT
> message.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>and textProducer frag abort einfo consumer =
let
    val len = TF.length TF.UseCrLf frag

    fun producer() =
    (
        CML.send(consumer, XferInfo(update_length einfo len));
        TF.apply TF.UseCrLf send frag;
        CML.send(consumer, XferDone)
    )

    and send str = CML.send(consumer, XferBytes(Byte.stringToBytes str))
in
    CML.spawn producer
end</PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>procProducer</TT
> function delivers an entity from a pipe
that is reading from a CGI script. This makes it a bit different
from the other producers in that it can only work once. The Info for
the entity is obtained from the headers returned by the CGI script.
See <A
HREF="x5210.html#DTLCGINODE"
>the section called <I
>The CGI Node Handler</I
></A
> for more details.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>and procProducer (holder: ExecReader.Holder) abort einfo consumer =
let
    val opened as (proc, _) = ExecReader.get holder
    val (strm, _) = Unix.streamsOf proc

    fun producer() =
    (
        CML.send(consumer, XferInfo einfo);
        send_file();
        ExecReader.closeIt holder;
        ()
    )


    and send_file () =
    (
        (*  See send_file above
            PROBLEM: CML timeouts don't seem to interrupt the inputN
            operation.
        *)
        if Abort.aborted abort
        then
        (
            CML.send(consumer, XferAbort)
        )
        else
        let
            val chunk = TextIO.inputN(strm, pipe_chunk)
        in
            if chunk = ""
            then
            (
                CML.send(consumer, XferDone)
            )
            else
            (
                CML.send(consumer, XferBytes(Byte.stringToBytes chunk));
                send_file()
            )
        end
        handle x =&#62; (Log.logExn x; ())
    )
in
    CML.spawn producer
end</PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>producer</TT
> function is straight-forward enough: send the info
then send the file then close.  Sending the file consists of a loop
to read chunks from the pipe and deliver them in <TT
CLASS="COMPUTEROUTPUT"
>XferBytes</TT
>
messages. As usual I need to check for an abort condition each time
around.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DTLHEADER"
>The HTTPHeader Module</A
></H2
><P
>The HTTPHeader module handles the parsing of the header lines in
messages. This isn't rocket science, just a lot of string handling,
so I won't go through all of the code in detail. I'll just describe the
overall layout.</P
><P
>Here is the type for a header.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>datatype Header = 
        HdrDate of Date.date
    |   HdrPragma of string

    |   HdrAuthorization of Authorization
    |   HdrFrom of string
    |   HdrIfModified of Date.date
    |   HdrReferer of string
    |   HdrUserAgent of string

    |   HdrConEnc of Entity.Encoding(* content encoding *)
    |   HdrConLen of int            (* content length *)
    |   HdrConType of Entity.MType  (* mime type *)
    |   HdrLastModified of Date.date

    |   HdrChallenge of AuthChallenge

    (*  These can appear in CGI script output. *)
    |   HdrStatus of HTTPStatus.Status
    |   HdrLocation of URL.URL

    |   HdrExt of (string * string) (* extensions *)
    |   HdrBad of string            (* unparsable junk *)


and Authorization =
        AuthBasic of (string option * string)  (* user id and password *)

and AuthChallenge =
        ChallBasic of string    (* the realm *)</PRE
></TD
></TR
></TABLE
><P
>The well-known headers are separated out.  Anything that isn't recognised
is thrown into the extension category (<TT
CLASS="COMPUTEROUTPUT"
>HdrExt</TT
>) and left as a pair
of strings for the header name and value.  The status header is included
since it appears in the CGI protocol. (See <A
HREF="x5210.html#DTLCGINODE"
>the section called <I
>The CGI Node Handler</I
></A
>).
Any header that cannot be parsed is thrown into the bad category
(<TT
CLASS="COMPUTEROUTPUT"
>HdrBad</TT
>) for later error reporting.</P
><P
>Here is the header interface.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val readAllHeaders: (unit -&#62; string option) -&#62; Header list

val parseHeader:    string -&#62; Header

val formatHeader: Header -&#62; TextFrag.Text

(*  These functions retrieve well-known headers. *)

val getContentLength:   Header list -&#62; int option
val getContentType:     Header list -&#62; Entity.MType option
val getContentEnc:      Header list -&#62; Entity.Encoding option
val getContentMod:      Header list -&#62; Date.date option
val getAuth:            Header list -&#62; Authorization option
val getStatus:          Header list -&#62; HTTPStatus.Status option
val getLocation:        Header list -&#62; URL.URL option

(*  This extracts the relevant headers to build the entity info
    record.
*)
val toEntityInfo:       Header list -&#62; Entity.Info

(*  This overrides one set of headers with another. *)
val overrideHeaders:    Header list -&#62; Header list -&#62; Header list

(*  This excludes a set of headers.  The excluded set is
    demonstrated by sample headers in the first list.
*)
val excludeHeaders:     Header list -&#62; Header list -&#62; Header list</PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>readAllHeaders</TT
> function reads and parses all of the header
section of a message. It stops after the blank line that ends a header
section.  The argument is a function for reading lines as strings from
a data source. The lines must have any trailing CR-LF trimmed off. The
<TT
CLASS="COMPUTEROUTPUT"
>Connect.readLine</TT
> function matches this requirement.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>readAllHeaders</TT
> function uses <TT
CLASS="COMPUTEROUTPUT"
>parseHeader</TT
> to parse each
header. This function can be called separately.  The <TT
CLASS="COMPUTEROUTPUT"
>formatHeader</TT
>
function restores a header to text form as a <TT
CLASS="COMPUTEROUTPUT"
>TextFrag</TT
>.</P
><P
>Next come a group of utility functions which fetch particular headers
from a list.  The <TT
CLASS="COMPUTEROUTPUT"
>toEntityInfo</TT
> function extracts those headers
relevant to the contents of an entity and builds an Info value (see
<A
HREF="x5496.html#DTLENTITY"
>the section called <I
>The Entity Module</I
></A
>).  The override and exclude functions allow
merging groups of headers. They aren't actually used anymore.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>readAllHeaders</TT
> function has this general scheme.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun readAllHeaders readLine : Header list =
let
... omitted material ...
    val lines = loop []
    val hdr_lines = merge lines [] []
    val headers = map parseHeader hdr_lines
in
    (* show_lines hdr_lines; *)
    headers
end</PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>loop</TT
> function reads in all of the header lines into a list. The
<TT
CLASS="COMPUTEROUTPUT"
>merge</TT
> function merges continuation lines.  If a line starts with
white space then it is a continuation of the previous line. The leading
white space of the continuation line is stripped off.  Then each line
is parsed.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>parseHeader</TT
> function has more meat in it.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>and parseHeader line : Header =
let

    val dispatch = [
        ("DATE",                parse_date HdrDate),
        ("PRAGMA",              parse_pragma),
        ("AUTHORIZATION",       parse_auth),
        ("FROM",                parse_from),
        ("IF-MODIFIED-SINCE",   parse_if_modified),
        ("REFERER",             parse_referer),
        ("USER-AGENT",          parse_useragent),
        ("CONTENT-ENCODING",    parse_cont_encoding),
        ("CONTENT-LENGTH",      parse_cont_length),
        ("CONTENT-TYPE",        parse_cont_type),
        ("LAST-MODIFIED",       parse_date HdrLastModified),
        ("WWW-AUTHENTICATE",    parse_challenge),
        ("LOCATION",            parse_location),
        ("STATUS",              parse_status)
        ]

    (*  The value has the leading and trailing white space removed. *)
    fun parse sstoken ssvalue =
    let
        val value = (SS.string(SS.dropl Char.isSpace
                                    (SS.dropr Char.isSpace ssvalue)))
        val token  = SS.string sstoken
        val utoken = upperCase token
    in
        case List.find (fn (n, _) =&#62; n = utoken) dispatch of
          NONE =&#62; HdrExt (token, value)

        | SOME (n, f) =&#62; f value
    end


    (*  The common characters are caught early for speed. *)
    fun is_token c = Char.isAlphaNum c orelse c = #"-" orelse
                     Char.contains "!#$%&#38;'*+.^_`|~" c orelse
                     (ord c &#62;= 128)


    val (name, rest) = SS.splitl is_token (SS.all line)
in
    (*  Expect a token, colon and more parts. *)
    if not (SS.isEmpty name) andalso SS.sub(rest, 0) = #":"
    then
        parse name (SS.triml 1 rest)
    else
        HdrBad line
end</PRE
></TD
></TR
></TABLE
><P
>Down the bottom I first separate out the header name which is a &quot;token&quot;
in the IETF terminology.  Splitting uses the <TT
CLASS="COMPUTEROUTPUT"
>Substring</TT
> type to
avoid copying parts of strings.  The <TT
CLASS="COMPUTEROUTPUT"
>parse</TT
> function converts the token
to upper case and looks it up in the dispatch table.  The dispatch
functions are passed the value of the header line after the colon with
the leading and trailing white space stripped.  These functions must
return a <TT
CLASS="COMPUTEROUTPUT"
>Header</TT
> value, possibly <TT
CLASS="COMPUTEROUTPUT"
>HdrBad</TT
>.</P
><P
>The date parsing dispatch function is shared by the different
headers.  The header's constructor is passed as an argument to the
function. Remember that a constructor in a datatype is equivalent
to a function that constructs the type.  See the <TT
CLASS="COMPUTEROUTPUT"
>parse_date</TT
>
function below.</P
><P
>Some header values consist of multiple tokens that need further
parsing. This is described in more detail in <A
HREF="x5496.html#DTLIETFLINE"
>the section called <I
>The IETF_Line and IETF_Part Modules</I
></A
>.
The result is a list of parts that are described by the following type in the
IETF_Part module. (In the code I abbreviate <TT
CLASS="COMPUTEROUTPUT"
>IETF_Part</TT
> to <TT
CLASS="COMPUTEROUTPUT"
>IP</TT
>
and <TT
CLASS="COMPUTEROUTPUT"
>IETF_Line</TT
> to <TT
CLASS="COMPUTEROUTPUT"
>IETF</TT
>.).</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>datatype Part =
        Token of string     (* including quoted strings *)
    |   TSpec of char
    |   TWh of string       (* the white space *)
    |   TBad  of char       (* invalid character *)
    |   TEOF</PRE
></TD
></TR
></TABLE
><P
>Here is a simple header parsing function for the Pragma header.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>and parse_pragma value =
let
    val hparts = IETF.split value
in
    case strip_ws hparts of
      [IP.Token s] =&#62;
    (
        if field_match s "no-cache"
        then
            HdrPragma "no-cache"
        else
            HdrBad value
    )

    | _ =&#62; HdrBad value
end</PRE
></TD
></TR
></TABLE
><P
>It splits the header value into parts and then checks that this
results in exactly one token. The only token that is recognised is
<TT
CLASS="COMPUTEROUTPUT"
>no-cache</TT
>. The <TT
CLASS="COMPUTEROUTPUT"
>field_match</TT
> function does case-insensitive
matching of two strings.</P
><P
>The most complicated parsing function is for dates. There are
three different date formats that are allowed in date headers.
See <A
HREF="x3288.html#DATEHEADER"
>the section called <I
>The Date Header</I
> in Chapter 8</A
> for more details.  Here is the top-level
of the function.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>and parse_date (constr: Date.date -&#62; Header) value =
let
    val hparts = IETF.split value
... omitted material ...
in
    (* print "looking at the date parts ";
       IETF.dump parts; print "\n"; *)

    case strip_ws hparts of
      [IP.Token wkday,
       IP.TSpec #",",
       IP.Token day,
       IP.Token month,
       IP.Token year,
       IP.Token hh,
       IP.TSpec #":",
       IP.Token mm,
       IP.TSpec #":",
       IP.Token ss,
       IP.Token "GMT"] =&#62; build wkday day month year hh mm ss

    | [IP.Token wkday,
       IP.TSpec #",",
       IP.Token dmy,        (* hyphen isn't special *)
       IP.Token hh,
       IP.TSpec #":",
       IP.Token mm,
       IP.TSpec #":",
       IP.Token ss,
       IP.Token "GMT"] =&#62;
        (
            case String.fields (fn c =&#62; c = #"-") dmy of
              [day, month, year] =&#62;
                  build wkday day month ("19"^year) hh mm ss

            | _ =&#62; HdrBad value
        )

    | [IP.Token wkday,
       IP.Token month,
       IP.Token day,
       IP.Token hh,
       IP.TSpec #":",
       IP.Token mm,
       IP.TSpec #":",
       IP.Token ss,
       IP.Token year] =&#62; build wkday day month year hh mm ss

    | _ =&#62; HdrBad value
end</PRE
></TD
></TR
></TABLE
><P
>The date value is split into tokens and then a big case expression
matches it against each of the date formats. The compiler will be able
optimise these cases to efficient code.  The second format is trickier
since the hyphen character is not considered a token separator. The
day-month-year field must be split again into fields on the hyphen
character.  The <TT
CLASS="COMPUTEROUTPUT"
>build</TT
> function assembles the field values into
a <TT
CLASS="COMPUTEROUTPUT"
>Date.date</TT
> value.  This involves recognising month and weekday
names.  I'll skip describing that here.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>formatHeader</TT
> function converts each header back to text
as fragments. This avoids all of the copying that would result from
concatenating strings.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>and formatHeader (HdrDate date) =
(
    format_date "Date: " date
)

|   formatHeader (HdrPragma pragma) =
(
    TF.L ["Pragma: ", IETF.quoteField pragma]
)
... omitted material ...</PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>quoteField</TT
> function reintroduces quoting for special characters
as described in <A
HREF="x3288.html#HTTPREQUESTS"
>the section called <I
>HTTP Requests</I
> in Chapter 8</A
>.</P
><P
>The remaining functions in this module are simple utility functions that
need no further explanation.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DTLIETFLINE"
>The IETF_Line and IETF_Part Modules</A
></H2
><P
>The IETF_Line module contains the code for splitting a string
into tokens and special characters according to the syntax in
<A
HREF="x3288.html#HTTPREQUESTS"
>the section called <I
>HTTP Requests</I
> in Chapter 8</A
>. The result is a list of parts described by
this type in the IETF_Part module.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>datatype Part =
        Token of string     (* including quoted strings *)
    |   TSpec of char
    |   TWh of string       (* the white space *)
    |   TBad  of char       (* invalid character *)
    |   TEOF</PRE
></TD
></TR
></TABLE
><P
>To help recognise the tokens and special characters I've used a
lexer generated by the ML-Lex utility (which is part of the SML/NJ
distribution).  ML-Lex is similar to the standard Unix lex utility
for the C language. You provide a specification of regular expressions
for the various parts you want to recognise and it builds a lexer for
these expressions.  Here is the body of the specification from the
<TT
CLASS="COMPUTEROUTPUT"
>ietf.lex</TT
> file.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>%structure IETFLex
%full

ctl=[\000-\031\127];
ws=[\ \t];
tokn=[!#$%&#38;'*+.0-9A-Z^_`a-z|~\h-];
str=[^\000-\031\127"];

%%

{ws}+           =&#62; (TWh yytext);
{tokn}+         =&#62; (Token yytext);
\"{str}*\"      =&#62; (fix_str yytext);

"("             =&#62; (TSpec (String.sub(yytext, 0)));
")"             =&#62; (TSpec (String.sub(yytext, 0)));
"&#60;"             =&#62; (TSpec (String.sub(yytext, 0)));
"&#62;"             =&#62; (TSpec (String.sub(yytext, 0)));
"@"             =&#62; (TSpec (String.sub(yytext, 0)));
","             =&#62; (TSpec (String.sub(yytext, 0)));
";"             =&#62; (TSpec (String.sub(yytext, 0)));
":"             =&#62; (TSpec (String.sub(yytext, 0)));
"\\"            =&#62; (TSpec (String.sub(yytext, 0)));
"\""            =&#62; (TSpec (String.sub(yytext, 0)));
"/"             =&#62; (TSpec (String.sub(yytext, 0)));
"["             =&#62; (TSpec (String.sub(yytext, 0)));
"]"             =&#62; (TSpec (String.sub(yytext, 0)));
"?"             =&#62; (TSpec (String.sub(yytext, 0)));
"="             =&#62; (TSpec (String.sub(yytext, 0)));
"{"             =&#62; (TSpec (String.sub(yytext, 0)));
"}"             =&#62; (TSpec (String.sub(yytext, 0)));

.               =&#62; (TBad (String.sub(yytext, 0)));</PRE
></TD
></TR
></TABLE
><P
>The generated SML file will contain a structure named <TT
CLASS="COMPUTEROUTPUT"
>IETFLex</TT
>.
This contains these declarations (among others).</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>structure IETFLex=
struct
    structure UserDeclarations =
    struct
        open IETF_Part
        type lexresult = Part

        fun eof() = TEOF

        (*      Strip off the surrounding quotes. *)
        fun fix_str s = Token(String.substring(s, 1, size s - 2))
    end

    fun makeLexer yyinput = ...
    ...
end</PRE
></TD
></TR
></TABLE
><P
>The contents of the <TT
CLASS="COMPUTEROUTPUT"
>UserDeclarations</TT
> structure is copied in
from the top part of the <TT
CLASS="COMPUTEROUTPUT"
>ietf.lex</TT
> file.  The <TT
CLASS="COMPUTEROUTPUT"
>lexresult</TT
>
declaration is required. It gives the type of the part that is returned
by the lexer.  The right-hand side of a regular expression specification
must be an expression of this type.   As in C lex, a variable named
<TT
CLASS="COMPUTEROUTPUT"
>yytext</TT
> is available containing the matched string.  The <TT
CLASS="COMPUTEROUTPUT"
>eof</TT
>
function is also required. It will be called at the end of the lexer's
input.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>makeLexer</TT
> function returns a lexer function that can be called
successively to get each part. So the lexer function is imperative. The
<TT
CLASS="COMPUTEROUTPUT"
>yyinput</TT
> argument to <TT
CLASS="COMPUTEROUTPUT"
>makeLexer</TT
> is a function that the lexer
can call to fetch chunks of the input string. It takes an integer argument
for the preferred chunk length, which you can ignore if you like. The end
of the input is indicated when <TT
CLASS="COMPUTEROUTPUT"
>yyinput</TT
> returns the empty string.</P
><P
>Here is the <TT
CLASS="COMPUTEROUTPUT"
>IETF_Line.split</TT
> function that operates the lexer.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun split str : IP.Part list =
let
    val done = ref false
    fun input n = if !done then "" else (done := true; str)

    val lexer = IETFLex.makeLexer input

    fun read toks =
    (
        case lexer() of
          IP.TEOF =&#62; rev toks
        | t       =&#62; read (t::toks)
    )
in
    read []
end</PRE
></TD
></TR
></TABLE
><P
>I pass the string to be split in a single chunk to the lexer.  I have
to arrange for the second call to the input function to return an empty
string. This requires a kludge with a state variable.  The imperative
nature of the lexer tends to poison like this all code that interacts
with it.  The <TT
CLASS="COMPUTEROUTPUT"
>read</TT
> function is a simple loop that keeps getting
parts from the lexer until the end-of-file part is found. A list of the
parts is returned.</P
><P
>Complementing the <TT
CLASS="COMPUTEROUTPUT"
>split</TT
> function is the <TT
CLASS="COMPUTEROUTPUT"
>join</TT
> function. This
converts a list of parts back into a string.  At the moment this only
used by the <TT
CLASS="COMPUTEROUTPUT"
>quoteField</TT
> function.  (In an earlier version of the
server I used the <TT
CLASS="COMPUTEROUTPUT"
>join</TT
> function in more places).</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>and join hparts =
let
    fun to_str []         rslt = concat(rev rslt)
    |   to_str [IP.TWh _] rslt = to_str [] rslt    (* trailing ws *)
    |   to_str ((IP.Token s1)::r) rslt = to_str r ((quote s1)::rslt)
    |   to_str ((IP.TWh s)::r)    rslt = to_str r (s :: rslt)
    |   to_str ((IP.TSpec c)::r)  rslt = to_str r ((str c) :: rslt)
    |   to_str ((IP.TBad  c)::r)  rslt = to_str r rslt
    |   to_str (IP.TEOF::r)       rslt = to_str r rslt


    and quote str =
    let
        (* If there are unsafe characters then right won't be empty.
        *)
        val (_, right) = SS.splitl safe (SS.all str)
    in
        if SS.isEmpty right
        then
            str
        else
            strip_dq str
    end


    and safe c = not (Char.isCntrl c orelse
                      Char.isSpace c orelse
                      Char.contains "()&#60;&#62;@,;:\\\"/[]?={}" c)

    and strip_dq str =
    let
        val fields = SS.fields (fn c =&#62; c = #"\"") (SS.all str)
    in
        concat("\"" :: ((map SS.string fields) @ ["\""]))
    end

in
    to_str hparts []
end</PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>to_str</TT
> function is the main loop that converts each
part to a string, building a list of strings.  Then this list
is concatenated. Trailing white space is deleted.  The text of
tokens is quoted if they contain unsafe characters.  I use the
<TT
CLASS="COMPUTEROUTPUT"
>Substring.splitl</TT
> function as a simple way to search for a
character that matches a predicate. If there are any unsafe characters
then the whole token is enclosed in double quotes. Since the HTTP v1.0
specification does not allow double quote characters inside quoted strings
I just delete them, for want of a better solution. There shouldn't be
any of them inside tokens anyway.</P
><P
>Now I can implement the <TT
CLASS="COMPUTEROUTPUT"
>quoteField</TT
> function as just a split followed by
a join.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>and quoteField field = join(split field)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DTLHTTPSTATUS"
>The HTTPStatus Module</A
></H2
><P
>This module provides a simple abstraction for status codes.  The codes
are classified by severity and protocol version.  The text description
of the code can be generated.</P
><P
>There's not much to say about this.  Each code is made into an exported value.
The type is abstract.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>datatype Severity =
    Info | Success | Redirect | ClientError | ServerError

type Status

val OK:             Status          (* 200 *)
val Created:        Status          (* 201 *)
val Accepted:       Status          (* 202 *)
val NoContent:      Status          (* 204 *)
... omitted material ...
val formatStatus:   Status -&#62; string

val severity:       Status -&#62; Severity
val code:           Status -&#62; int

val isV11:          Status -&#62; bool
val same:           Status -&#62; Status -&#62; bool

val fromInt:        int -&#62; Status

(*  This tests if the response needs a body according to the
    status code.  See section 7.2 of RFC1945.
*)
val needsBody:      Status -&#62; bool</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DTLHTTPMSG"
>The HTTPMsg Module</A
></H2
><P
>This module defines types for the <TT
CLASS="COMPUTEROUTPUT"
>Request</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>Response</TT
>
types that pass between the HTTP protocol section and the resource
store. For more information see <A
HREF="x3709.html#REQRESPONSE"
>the section called <I
>Requests and Responses</I
> in Chapter 8</A
>.
&#13;</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x5210.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x5681.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>The Store Layer</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c4671.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>The Config Layer</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
