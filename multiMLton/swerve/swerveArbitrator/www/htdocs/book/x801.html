<HTML
><HEAD
><TITLE
>Text</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="The Basis Library"
HREF="c710.html"><LINK
REL="PREVIOUS"
TITLE="Bool"
HREF="x789.html"><LINK
REL="NEXT"
TITLE="Integers"
HREF="x892.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x789.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. The Basis Library</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x892.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN801"
>Text</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN803"
>The Types</A
></H2
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>String</TT
> structure provides a typical collection of string operations.
The documentation is straightforward.  </P
><P
>Note that all subscripts are range checked.  This can be a big performance
hit if you use, for example, the <TT
CLASS="COMPUTEROUTPUT"
>sub</TT
> function to search through
a string.  Where possible you should use some of the other functions.
Alternatively you may find that using <TT
CLASS="COMPUTEROUTPUT"
>explode</TT
> followed by list
operations is faster, at the cost of using more memory.  If you really
need to do a lot of fast indexing into a string you can find a subscript
function without range checking in the <TT
CLASS="COMPUTEROUTPUT"
>Unsafe.CharVector.sub</TT
>
function, which you can find in the <TT
CLASS="COMPUTEROUTPUT"
>boot/Unsafe</TT
> directory of the
compiler source.</P
><P
>The current version of SML/NJ (110.0.7) does not implement wide strings.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>Char</TT
> structure provides a typical collection of character
operations, again straightforward.  The character classification functions
like <TT
CLASS="COMPUTEROUTPUT"
>isSpace</TT
> and case conversion are here.</P
><P
>Here are some examples.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun uppercase s = String.map Char.toUpper s

(*  Apply HTML quoting. *)
fun quoteHTML v =
let
    fun quote #"\"" = "&#38;quot;"
    |   quote #"&#38;"  = "&#38;amp;"
    |   quote #"&#60;"  = "&#38;lt;"
    |   quote c     = str c
in
    String.translate quote v
end

(*   Break a string into words at white space. *)
fun split s = String.tokens Char.isSpace s</PRE
></TD
></TR
></TABLE
><P
>For more elaborate string parsing on large strings the functions in the
<TT
CLASS="COMPUTEROUTPUT"
>Substring</TT
> structure will be more efficient.  A substring is represented
as a pointer to a range of characters in an underlying string.  So you can
work on pieces of the string without any copying.  Here are some examples.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun skipWhiteSpace s =
    Substring.string(
        Substring.dropl Char.isSpace (Substring.all s))

fun countLines s =
    Substring.foldl
        (fn (ch,n) =&#62; if ch = #"\n" then n+1 else n) 1
        (Substring.all s)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="TEXTSCANNING"
>Text Scanning</A
></H2
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>StringCvt</TT
> structure provides the infrastructure for reading
values out of text.  The infrastructure is based around the idea of a
reader function that can split a value off of the beginning of a stream.
Then there are transformers that build up more complex readers from
simpler readers.   </P
><P
>You have complete freedom in how you represent and implement streams just
as long as they have a functional style.  This means that if you have a
stream <TT
CLASS="COMPUTEROUTPUT"
>strm</TT
> and a <TT
CLASS="COMPUTEROUTPUT"
>get</TT
> function that gets the first value
of the stream then the expression <TT
CLASS="COMPUTEROUTPUT"
>(get strm)</TT
> can be evaluated as
many times as you like and it will always return the same value since
it has no side-effects on the stream.  The type of a reader function is</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type ('a, 'b) reader = 'b -&#62; ('a * 'b) option</PRE
></TD
></TR
></TABLE
><P
>In this, type <TT
CLASS="COMPUTEROUTPUT"
>'b</TT
> represents the stream and <TT
CLASS="COMPUTEROUTPUT"
>'a</TT
> is a value
from the stream.  The reader function returns one value from the front
of the stream along with the remainder of the stream. An option type
is used with NONE representing failure to find a value in the stream.
So for example if <TT
CLASS="COMPUTEROUTPUT"
>strm</TT
> contains the characters <TT
CLASS="COMPUTEROUTPUT"
>&quot;abc&quot;</TT
> and
<TT
CLASS="COMPUTEROUTPUT"
>get</TT
> is a character reader then <TT
CLASS="COMPUTEROUTPUT"
>(get strm)</TT
> returns the first
character from the stream along with the rest of the stream as the pair
<TT
CLASS="COMPUTEROUTPUT"
>SOME(#&quot;a&quot;, &quot;bc&quot;)</TT
>.</P
><P
>Transformer functions convert a stream of some type T to a stream of
another type U. In the infrastructure they are applied on the fly.
You have to at some point arrive at a stream of characters for the text
scanning. <A
HREF="x801.html#BUFFERSTREAM"
>Figure 3-1</A
> shows an example of transformations
for reading a stream of integers from character buffers. You write your
transformer that can deliver characters one by one from the buffers.
This will involve maintaining an offset into the buffer for where the
next character will come from.  Then you can use the <TT
CLASS="COMPUTEROUTPUT"
>Int.scan</TT
>
function to transform this stream of characters into a stream of integers.</P
><DIV
CLASS="FIGURE"
><A
NAME="BUFFERSTREAM"
></A
><P
><B
>Figure 3-1. Some Stream Transformations</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><center><IMG
SRC="basis/bufferStream.png"
></center></IMG
></P
></DIV
></DIV
><P
>Some possible sources of character streams are:</P
><P
></P
><UL
><LI
><P
>   a string. The <TT
CLASS="COMPUTEROUTPUT"
>StringCvt.scanString</TT
> will transform
            a string to a character stream and deliver it to
            a transformer, and return the first value from the
            transformed stream.  It is designed for one-off use to
            implement <TT
CLASS="COMPUTEROUTPUT"
>fromString</TT
> functions.</P
></LI
><LI
><P
>   an input stream from a file.  The <TT
CLASS="COMPUTEROUTPUT"
>TextIO.scanStream</TT
>
            function will deliver a stream of characters from a file
            to a transformer and then return the first value from the
            transformed stream.  Since I/O streams are imperative the
            stream will be updated but it will be pure enough to complete
            the reading of the value.</P
></LI
><LI
><P
>   a list of characters.  The <TT
CLASS="COMPUTEROUTPUT"
>List.getItems</TT
> function
            can deliver list elements matching the requirements of
            a reader.</P
></LI
><LI
><P
>   a substring of a string using <TT
CLASS="COMPUTEROUTPUT"
>Substring.getc</TT
>.</P
></LI
></UL
><P
>Here is an example of a function that transforms a character stream by
splitting the stream into lines and extracting a triple of an integer,
boolean and a real from each line.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun ibr rdr the_cstrm =
let
    (*  Read all characters to the end of the
        string or a newline.  This returns the
        line and the rest of the stream.
    *)
    fun get_line cstrm rev_line =
    (
        case rdr cstrm of
          NONE =&#62; (cstrm, implode(rev rev_line))
                            (* ran out of chars *)

        | SOME (c, rest) =&#62; 
        (
            if c = #"\n"
            then
                (rest, implode(rev rev_line))
            else
                get_line rest (c::rev_line)
        )
    )

    val (strm_out, line) = get_line the_cstrm []
    val l1 = Substring.all line

    val (i, l2) = valOf(Int.scan StringCvt.DEC
                            Substring.getc l1)
    val (b, l3) = valOf(Bool.scan Substring.getc l2)
    val (r, l4) = valOf(Real.scan Substring.getc l3)
in
    SOME((i, b, r), strm_out)
end
handle Option =&#62; NONE</PRE
></TD
></TR
></TABLE
><P
>The transformer must take a character reader as an argument so I want
the expression <TT
CLASS="COMPUTEROUTPUT"
>(ibr rdr)</TT
> to be a reader that reads triples when
<TT
CLASS="COMPUTEROUTPUT"
>rdr</TT
> is a character reader. But a reader is a function taking a
stream as an argument.  So if I define the function as 
<TT
CLASS="COMPUTEROUTPUT"
>fun ibr rdr the_cstrm</TT
> where <TT
CLASS="COMPUTEROUTPUT"
>the_cstrm</TT
> is the character
stream to read then, using currying, the expression <TT
CLASS="COMPUTEROUTPUT"
>(ibr rdr)</TT
>
will be of the correct type, i.e. a function taking a character stream.</P
><P
>The first thing the transformer does is read characters from the stream
until it has a complete line.  The characters are accumulated into a
list in reverse. At the end they are joined into a string.  This is the
fastest way to accumulate a string from characters.</P
><P
>Next I want to get the line into a stream that can be scanned.  The
<TT
CLASS="COMPUTEROUTPUT"
>Substring.getc</TT
> function satisfies the requirements for a reader
function if the stream is a substring.  Then I can call the scan functions
for each type to get the values on the line.  Note that I get back an
updated substring in the <TT
CLASS="COMPUTEROUTPUT"
>l2</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>l3</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>l4</TT
> variables.
I use <TT
CLASS="COMPUTEROUTPUT"
>valOf</TT
> to get the result out from under the <TT
CLASS="COMPUTEROUTPUT"
>SOME</TT
>.
If the scan fails then it will return <TT
CLASS="COMPUTEROUTPUT"
>NONE</TT
> which will cause <TT
CLASS="COMPUTEROUTPUT"
>valOf</TT
> to
raise the <TT
CLASS="COMPUTEROUTPUT"
>Option</TT
> exception.  A reader function indicates failure
by returning <TT
CLASS="COMPUTEROUTPUT"
>NONE</TT
> so that's what the exception handler does.</P
><P
>The main program shows how <TT
CLASS="COMPUTEROUTPUT"
>StringCvt.scanString</TT
> applies the
transformer to a string returning exactly one result.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun main(arg0, argv) =
let
    val text = "\
            \  123 true  23.4       \n\
            \  -1  false -1.3e3     \n\
            \"
in
    case StringCvt.scanString ibr text of
      NONE =&#62; print "ibr failed\n"

    | SOME (i, b, r) =&#62; print(concat[
            Int.toString i, " ",
            Bool.toString b, " ",
            Real.toString r, "\n"
            ]);

    OS.Process.success
end</PRE
></TD
></TR
></TABLE
><P
>See the documentation for <TT
CLASS="COMPUTEROUTPUT"
>StringCvt</TT
> for more details.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN886"
>Bytes</A
></H2
><P
>Bytes are represented by the type <TT
CLASS="COMPUTEROUTPUT"
>word</TT
> in the <TT
CLASS="COMPUTEROUTPUT"
>Word8</TT
>
structure.  The <TT
CLASS="COMPUTEROUTPUT"
>Byte</TT
> structure provides conversions between
strings of characters and sequences of bytes.  This will be especially
useful for the web server project since reading and writing to TCP/IP
sockets is done with bytes which we will want to convert to strings.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x789.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x892.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Bool</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c710.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Integers</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
