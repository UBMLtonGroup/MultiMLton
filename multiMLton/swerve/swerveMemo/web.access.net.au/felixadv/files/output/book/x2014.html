<HTML
><HEAD
><TITLE
>Algorithms</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="The Utility Libraries"
HREF="c1812.html"><LINK
REL="PREVIOUS"
TITLE="The Utility Libraries"
HREF="c1812.html"><LINK
REL="NEXT"
TITLE="Regular Expressions"
HREF="x2239.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c1812.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. The Utility Libraries</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x2239.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN2014"
>Algorithms</A
></H1
><P
>This section describes the algorithms in the Util directory of the
SML/NJ library.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2017"
>Sorting and Searching</A
></H2
><P
>The utility library provides a functional polymorphic merge-sort
for lists.  It is in the <TT
CLASS="COMPUTEROUTPUT"
>ListMergeSort</TT
> structure of the
<TT
CLASS="COMPUTEROUTPUT"
>list-mergesort.sml</TT
> source file.  Here is the signature.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>signature LIST_SORT =
sig
     val sort : ('a * 'a -&#62; bool) -&#62; 'a list -&#62; 'a list  
        (* (sort gt l) sorts the list l in ascending order using the
         * ``greater-than'' relationship defined by gt.
         *)

     val uniqueSort : ('a * 'a -&#62; order) -&#62; 'a list -&#62; 'a list
       (* uniquesort produces an increasing list, removing equal 
        * elements
        *)

     val sorted : ('a * 'a -&#62; bool) -&#62; 'a list -&#62; bool  
        (* (sorted gt l) returns true if the list is sorted in ascending
         * order under the ``greater-than'' predicate gt.
         *)
end</PRE
></TD
></TR
></TABLE
><P
>Here is an example of their use.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val strings = [ "fred",
                "wilma",
                "barney",
                "betty",
                "wilma",
                "pebbles",
                "bambam"
            ]


fun sort_strings (data: string list) =
(
    ListMergeSort.sort (op &#62;) data
)


fun unique_strings (data: string list) =
(
    ListMergeSort.uniqueSort String.compare data
)</PRE
></TD
></TR
></TABLE
><P
>The expression <TT
CLASS="COMPUTEROUTPUT"
>(op &#62;)</TT
> has an ambiguous overloaded type.
The compiler has to be able to decide the type at compile time so
it can't be polymorphic over all types with a greater-than operator.
In <TT
CLASS="COMPUTEROUTPUT"
>sort_strings</TT
> the type is fixed at string comparison by the
context.  I could have been more explicit and written <TT
CLASS="COMPUTEROUTPUT"
>String.&#62;</TT
>
for the operator.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>unique_strings</TT
> function removes duplicate strings from
the list.  The family of compare functions for the basic types return
the three-way comparison: <TT
CLASS="COMPUTEROUTPUT"
>LESS</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>EQUAL</TT
> or <TT
CLASS="COMPUTEROUTPUT"
>GREATER</TT
>.</P
><P
>If you are working with arrays there is a quick-sort implementation
in <TT
CLASS="COMPUTEROUTPUT"
>ArrayQSort</TT
> with the following signature.  It sorts an array
in-place so it's imperative.  It uses the compare functions such as the
<TT
CLASS="COMPUTEROUTPUT"
>String.compare</TT
> I mentioned above.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>signature ARRAY_SORT =
sig
    type 'a array

    val sort   : ('a * 'a -&#62; order) -&#62; 'a array -&#62; unit
    val sorted : ('a * 'a -&#62; order) -&#62; 'a array -&#62; bool
end</PRE
></TD
></TR
></TABLE
><P
>A more abstract version of this for any array-like types is provided by this functor.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>functor ArrayQSortFn (A : MONO_ARRAY) : MONO_ARRAY_SORT

signature MONO_ARRAY_SORT =
sig
    structure A : MONO_ARRAY

    val sort:    (A.elem * A.elem -&#62; order) -&#62; A.array -&#62; unit
    val sorted:  (A.elem * A.elem -&#62; order) -&#62; A.array -&#62; bool
end</PRE
></TD
></TR
></TABLE
><P
>Once you've sorted your array you can do a binary search on it.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>functor BSearchFn (A : MONO_ARRAY) : sig

    structure A : MONO_ARRAY

    (*  binary search on ordered monomorphic arrays. The comparison
        function cmp embeds a projection function from the element type
        to the key type.
    *)
    val bsearch : (('a * A.elem) -&#62; order)
          -&#62; ('a * A.array) -&#62; (int * A.elem) option
    end</PRE
></TD
></TR
></TABLE
><P
>The first argument to <TT
CLASS="COMPUTEROUTPUT"
>bsearch</TT
> is the comparison function. It
compares the key you are searching for with an element in the array.
For example the array element might be a pair and you want to compare the
key against the first element of the pair.  The second is a pair of the
key to search for and the array.  If the array element is found then its
index and value is returned.  Here is an example of table lookup using
binary search.  The table is &quot;static&quot; i.e. built and sorted before being
saved to the heap.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>local
    datatype Gender = Male | Female

    type Pair = string * Gender

    (*  Compare two pairs. *)
    fun compare ((n1, _), (n2, _)) = String.compare(n1, n2)

    structure PairArray = MonoArrayFn(type elem = Pair)
    structure Searcher  = BSearchFn(PairArray)
    structure Sorter    = ArrayQSortFn(PairArray)

    val gender = [  ("fred",        Male),
                    ("wilma",       Female),
                    ("barney",      Male),
                    ("betty",       Female),
                    ("wilma",       Female),
                    ("pebbles",     Female),
                    ("bambam",      Male)
                ]

    val sorted_gender = PairArray.fromList gender
    val _ = Sorter.sort compare sorted_gender
in
    fun find_gender name =
    let
        (* Compare a key with a pair *)
        fun cmp (key, (n, _)) = String.compare(key, n)
    in
        case Searcher.bsearch cmp (name, sorted_gender) of
          NONE             =&#62; NONE
        | SOME (_, (_, g)) =&#62; SOME g
    end


    fun show_gender Male   = "male"
    |   show_gender Female = "female"
end</PRE
></TD
></TR
></TABLE
><P
>Since <TT
CLASS="COMPUTEROUTPUT"
>BSearchFn</TT
> needs a <TT
CLASS="COMPUTEROUTPUT"
>MONO_ARRAY</TT
> I have to be consistent
and use <TT
CLASS="COMPUTEROUTPUT"
>ArrayQSortFn</TT
> too.  The following code, for example,
doesn't work.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val sorted_gender = Array.fromList gender
val _ = ArrayQSort.sort compare sorted_gender

Error: case object and rules don't agree [tycon mismatch]
  operator domain: string * PairArray.array
  operand:         string * (string * Gender) array
  in expression:
    (Searcher.bsearch cmp) (name,sorted_gender)</PRE
></TD
></TR
></TABLE
><P
>The issue is that <TT
CLASS="COMPUTEROUTPUT"
>PairArray.array</TT
> is an opaque type of unknown
implementation whereas <TT
CLASS="COMPUTEROUTPUT"
>ArrayQSort.sort</TT
> works on the specialised
type <TT
CLASS="COMPUTEROUTPUT"
>Pair array</TT
>.  The two are different types as far as the
compiler can tell.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2054"
>Formatted Strings</A
></H2
><P
>The utility library provides a <TT
CLASS="COMPUTEROUTPUT"
>format</TT
> function which emulates
the C <TT
CLASS="COMPUTEROUTPUT"
>sprintf</TT
> function.  It appears in the <TT
CLASS="COMPUTEROUTPUT"
>Format</TT
> structure
of the <TT
CLASS="COMPUTEROUTPUT"
>format.sml</TT
> source file.  Here is the signature.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>signature FORMAT =
sig
    datatype fmt_item
      = ATOM of Atom.atom
      | LINT of LargeInt.int
      | INT of Int.int
      | LWORD of LargeWord.word
      | WORD of Word.word
      | WORD8 of Word8.word
      | BOOL of bool
      | CHR of char
      | STR of string
      | REAL of Real.real
      | LREAL of LargeReal.real
      | LEFT of (int * fmt_item)  (* left justify in field *)
      | RIGHT of (int * fmt_item) (* right justify in field *)

    exception BadFormat         (* bad format string *)
    exception BadFmtList        (* raised on type mismatch *)

    val format  : string -&#62; fmt_item list -&#62; string
    val formatf : string -&#62; (string -&#62; unit) -&#62; fmt_item list -&#62; unit
end</PRE
></TD
></TR
></TABLE
><P
>The first argument to the <TT
CLASS="COMPUTEROUTPUT"
>format</TT
> function is a printf-style format
string.  In place of the C varargs mechanism your values to be printed
must be wrapped in the <TT
CLASS="COMPUTEROUTPUT"
>fmt_item</TT
> datatype.  The <TT
CLASS="COMPUTEROUTPUT"
>formatf</TT
>
function can be used to print the string as it is being formed by making
its second argument the <TT
CLASS="COMPUTEROUTPUT"
>TextIO.print</TT
> function.</P
><P
>The formats that are recognised have the format </P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>"% &#60;flags&#62; &#60;width&#62; &#60;prec&#62; &#60;type&#62;" </PRE
></TD
></TR
></TABLE
><P
>(without the white space) or &quot;%%&quot; for a literal percent character.
The flags are listed in <A
HREF="x2014.html#FMTFLAGS"
>Table 5-1</A
>.  You can have more than
one flag.  The width is a decimal integer. The precision value is only
allowed for real number formats.</P
><DIV
CLASS="TABLE"
><A
NAME="FMTFLAGS"
></A
><P
><B
>Table 5-1. Format flags.</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>&quot; &quot;</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>A blank character means put a blank in the sign field for positive numbers.
	Negative signs will appear as usual.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>+</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Put a plus sign for positive numbers.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>-</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Put a minus sign for negative numbers.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>~</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Put a tilde for negative numbers. This includes any exponent.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>#</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Include a base indicator. This means &quot;0&quot; for octal numbers and
	&quot;0x&quot; for hexadecimal numbers.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>0</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Pad the number with zeros on the left.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>The type characters are listed in <A
HREF="x2014.html#FMTTYPES"
>Table 5-2</A
>.</P
><DIV
CLASS="TABLE"
><A
NAME="FMTTYPES"
></A
><P
><B
>Table 5-2. Format types.</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>d</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Signed decimal.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>X</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Uppercase hexadecimal.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>x</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Lowercase hexadecimal.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>o</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Octal.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>c</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Char.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>s</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>String.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>b</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Bool.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>E</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Scientific notation with an uppercase exponent.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>e</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Scientific notation with a lowercase exponent.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>f</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Floating point.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>G</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Automatic choice of E or f.</P
></TD
></TR
><TR
><TD
WIDTH="57"
ALIGN="CENTER"
VALIGN="TOP"
><P
>g</P
></TD
><TD
WIDTH="510"
ALIGN="LEFT"
VALIGN="TOP"
><P
>Automatic choice of e or f.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>Here is a simple example.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>structure F = Format

fun test_format() =
(
    F.formatf
        "A decimal %d, some hex %#08x and some real %.4f\n"
        print
        [F.INT ~23, F.WORD 0wxbeef, F.REAL 3.14159265]
)</PRE
></TD
></TR
></TABLE
><P
>It produces this output.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>A decimal -23, some hex 0x00beef and some real 3.1416</PRE
></TD
></TR
></TABLE
><P
>Note that the <TT
CLASS="COMPUTEROUTPUT"
>0x</TT
> is counted in the width of the hexadecimal field
but that's they way it happens in the C <TT
CLASS="COMPUTEROUTPUT"
>printf</TT
> too.</P
><P
>To go with the format function there is a scan function, in the Scan
structure.  Here is the signature.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>signature SCAN =
sig
    datatype fmt_item
      = ATOM of Atom.atom
      | LINT of LargeInt.int
      | INT of Int.int
      | LWORD of LargeWord.word
      | WORD of Word.word
      | WORD8 of Word8.word
      | BOOL of bool
      | CHR of char
      | STR of string
      | REAL of Real.real
      | LREAL of LargeReal.real
      | LEFT of (int * fmt_item)        (* left justify in field *)
      | RIGHT of (int * fmt_item)       (* right justify in field *)

    exception BadFormat                 (* bad format string *)

    val sscanf : string -&#62; string -&#62; fmt_item list option
    val scanf  : string -&#62; (char, 'a) StringCvt.reader
          -&#62; (fmt_item list, 'a) StringCvt.reader

end</PRE
></TD
></TR
></TABLE
><P
>Although it is not obvious, the <TT
CLASS="COMPUTEROUTPUT"
>fmt_item</TT
> type in the <TT
CLASS="COMPUTEROUTPUT"
>Scan</TT
>
structure is the same one as in the <TT
CLASS="COMPUTEROUTPUT"
>Format</TT
> structure, not just
different types with the same name. So you can use them interchangably.
In the current implementation flags and field widths in the format string
are ignored.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>scanf</TT
> function is designed to work with the StringCvt
scanning infrastructure (see <A
HREF="x801.html#TEXTSCANNING"
>the section called <I
>Text Scanning</I
> in Chapter 3</A
>).  The
<TT
CLASS="COMPUTEROUTPUT"
>sscanf</TT
> function is just defined as scanf applied to strings
using <TT
CLASS="COMPUTEROUTPUT"
>StringCvt.scanString</TT
>.  If the return value is NONE then
the scan failed.  Here is a simple function to test <TT
CLASS="COMPUTEROUTPUT"
>sscanf</TT
>.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>structure S = Scan

fun test_scan() : unit =
let
    val items = valOf(S.sscanf "%d %s %f" "123 abc 3.45")

    val display = ListFormat.fmt {
                    init  = "[",
                    sep   = " ",
                    final = "]",
                    fmt   = show_item
                    } items
in
    print display; print "\n"
end


and show_item (S.INT n)  = Int.toString n
|   show_item (S.STR s)  = s
|   show_item (S.REAL r) = Real.toString r
|   show_item _          = "unknown"&#13;</PRE
></TD
></TR
></TABLE
><P
>This example also demonstrates a use of the utilities in the
<TT
CLASS="COMPUTEROUTPUT"
>ListFormat</TT
> structure.  See the <TT
CLASS="COMPUTEROUTPUT"
>list-format-sig.sml</TT
> source
file for more details.</P
><P
>Here is a demonstration of <TT
CLASS="COMPUTEROUTPUT"
>scanf</TT
>.  It will continue to read until
it finds three integers separated by white space, even over several
lines. Any other input will result in failure.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fun test_scan_io() =
let
    val _ = print "Enter 3 integers\n"
in
    case TextIO.scanStream (S.scanf "%d %d %d") TextIO.stdIn of
      SOME items =&#62; (
        print "got ";
        print (ListFormat.listToString show_item items);
        print "\n"
        )

    | NONE =&#62; print "The reading failed\n"
end</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2201"
>Miscellaneous Utilities</A
></H2
><P
>The recommended random number generator is <TT
CLASS="COMPUTEROUTPUT"
>Random</TT
> in the
<TT
CLASS="COMPUTEROUTPUT"
>random.sml</TT
> source file.  According to the blurb in the source
file it uses <I
CLASS="EMPHASIS"
>a subtract-with-borrow (SWB) generator as described
in Marsaglia and Zaman, &quot;A New Class of Random Number Generators,&quot;
Ann. Applied Prob. 1(3), 1991, pp. 462-480</I
>.  Here is an extract from
the signature.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>signature RANDOM =
sig
    type rand
        (* the internal state of a random number generator *)

    val rand:       (int * int) -&#62; rand
        (* create rand from initial seed *)

    val toString:   rand -&#62; string
    val fromString: string -&#62; rand

    val randInt:    rand -&#62; int
        (* generate ints uniformly in [minInt,maxInt] *)</PRE
></TD
></TR
></TABLE
><P
>A generator has the type <TT
CLASS="COMPUTEROUTPUT"
>rand</TT
>.  You can create as many generators
as you like.  A generator is updated imperatively by functions like
<TT
CLASS="COMPUTEROUTPUT"
>randInt</TT
>.  The <TT
CLASS="COMPUTEROUTPUT"
>toString</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>fromString</TT
> functions
would be useful to save the state of a generator in a file.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>IOUtil</TT
> structure in <TT
CLASS="COMPUTEROUTPUT"
>io-util.sml</TT
> contains some
functions which perform a work function with the standard input or output
redirected to a file. They match some utility functions available in
the Scheme language.  The functions in the <TT
CLASS="COMPUTEROUTPUT"
>PathUtil</TT
> structure
in <TT
CLASS="COMPUTEROUTPUT"
>path-util.sml</TT
> search for files in lists of directories in the
Unix PATH format.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>Iterate</TT
> structure in <TT
CLASS="COMPUTEROUTPUT"
>iterate.sml</TT
> provides some
simple functions for looping by performing a function multiple times.
It includes a generic &quot;for&quot; loop, in case you're hankering for one.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>TimeLimit</TT
> structure in <TT
CLASS="COMPUTEROUTPUT"
>time-limit.sml</TT
> provides
a function to perform a work function and interrupt it if it runs
for too long.  It uses the SML/NJ interval timer facility (see
<A
HREF="x1503.html#INTERVALTIMER"
>the section called <I
>The Interval Timer</I
> in Chapter 4</A
>) which uses the <TT
CLASS="COMPUTEROUTPUT"
>SIGALRM</TT
> signal.</P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Don't use <TT
CLASS="COMPUTEROUTPUT"
>TimeLimit</TT
> with CML</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>Because it uses SIGALRM, which is the same signal that the CML library
uses, it will ruin the pre-emption of threads.</P
></TD
></TR
></TABLE
></DIV
><P
>The remaining few structures in the utility library are oriented
towards compiler writers.  The <TT
CLASS="COMPUTEROUTPUT"
>GraphSCCFn</TT
> functor in
<TT
CLASS="COMPUTEROUTPUT"
>graph-scc.sml</TT
> is a strongly-connected components algorithm for
finding cycles in directed graphs.  The &quot;uref&quot; source files provide
special-purpose reference types that look like they would be useful for
type-checking algorithms in compilers.  The <TT
CLASS="COMPUTEROUTPUT"
>ParserComb</TT
> structure
in <TT
CLASS="COMPUTEROUTPUT"
>parser-comb.sml</TT
> provides some utility functions for hand-written
recursive-descent parsers but ML-Lex and ML-Yacc would probably be easier
to use.</P
><P
>Avoid the <TT
CLASS="COMPUTEROUTPUT"
>IntInf</TT
> structure in <TT
CLASS="COMPUTEROUTPUT"
>int-inf.sml</TT
> which implements
arbitrary precision integers.  A more polished implementation is part
of the Basis library (see <A
HREF="x892.html"
>the section called <I
>Integers</I
> in Chapter 3</A
>).</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c1812.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x2239.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>The Utility Libraries</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c1812.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Regular Expressions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
