<HTML
><HEAD
><TITLE
>The CML Model</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Unix System Programming with Standard ML"
HREF="index.html"><LINK
REL="UP"
TITLE="Concurrency"
HREF="c2344.html"><LINK
REL="PREVIOUS"
TITLE="Coroutines"
HREF="x2405.html"><LINK
REL="NEXT"
TITLE="A Counter Object"
HREF="x2564.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="book.css"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unix System Programming with Standard ML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x2405.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 6. Concurrency</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x2564.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CMLMODEL"
>The CML Model</A
></H1
><P
>CML provides the following concurrent features:</P
><P
></P
><UL
><LI
><P
>   threads;</P
></LI
><LI
><P
>   channels for passing messages;</P
></LI
><LI
><P
>   events to signal when a message has arrived, I/O has completed or a
        timeout has occurred;</P
></LI
><LI
><P
>   synchronous variables;  </P
></LI
><LI
><P
>   mailboxes which are buffered asynchronous channels.</P
></LI
></UL
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CMLMODELTHREADS"
>CML Threads</A
></H2
><P
><A
HREF="x2442.html#CMLTHREAD"
>Figure 6-3</A
> shows the typical structure of a thread in a
CML program.  The thread may receive messages from one or more input
channels on the left. It may write messages to one or more output
channels on the right.  The thread may also do conventional file I/O.
The body of the thread is implemented as a function.  Typically this will
contain a loop that runs a state machine.  The function maps the pair
(current state, inputs) to (next state, outputs) and then it loops.
The function contains an environment which is the set of variables
captured by it from surrounding scopes or passed in as arguments.
These will typically supply the channels, files etc. that the thread
will communicate on.  The function can be written to be pure with all
of its state being passed through the arguments.</P
><DIV
CLASS="FIGURE"
><A
NAME="CMLTHREAD"
></A
><P
><B
>Figure 6-3. A CML Thread</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><center><IMG
SRC="concur/cmlThread.png"
></center></IMG
></P
></DIV
></DIV
><P
>Threads can be created dynamically and are light-weight enough that you
can structure your program with large numbers of threads.</P
><P
>Messages on a channel are normal values and can be of any type.  However
each channel has a single type.  If you need to pass values of different
types then you will need to either combine them into a datatype or have
separate channels.  Functions dealing with channels can be polymorphic
over the type of the channel.</P
><P
>The CML model has some parallels with the object-oriented model.
Originally classes and objects were introduced in the Simula language
[<SPAN
CLASS="CITATION"
><A
HREF="b6666.html#BIBE.SIMULA"
><I
>Simula</I
></A
></SPAN
>] which was designed for simulating (discrete event-based)
real-world systems.  Objects represented real-world entities.  Today it
is common to explain object-oriented concepts by showing how to model the
real-world entities as objects and describe the differences, commonalities
and relationships between objects using classes.  Each object interacts
with the other objects by sending and receiving messages.  An object
contains some private state which may be updated as a result of the
messages it receives.</P
><P
>But real-world systems are naturally concurrent. There have been several
attempts at designing concurrent object-oriented languages but this
is difficult in the imperative programming paradigm because of the
necessity to protect the imperative state from concurrent update and to
manage the correct ordering of update operations when parts of the system
are operating asynchronously.  The root of the problem is that state in
imperative programs is finely divided into imperative variables and spread
throughout the program creating a great many points to pay attention to.</P
><P
>The way I use CML is to think of each thread as representing a concurrent
object in the system.  The objects will be coarse-grained representing
major divisions of the system architecture rather than the fine-grained
&quot;everything is an object&quot; idea that some languages push.  The body of
the object is usually implemented as a pure function with all of the
state of the object segregated into a single state value that is passed
around outside of the function.  The result is a hybrid paradigm that
is imperative with objects and state at the top level and is functional
at the level of the implementation of the objects.</P
><P
>In a conventional language like Java or C++ in a multi-threaded program
a piece of code may be executed by more than one thread at a time.
This creates the need for identifying critical sections which must
be executed by at most one thread at a time.  You could get into
similar difficulties in CML if you try to have threads updating shared
reference variables.  Instead, following a concurrent object paradigm,
you would wrap each piece of state into an object which controls access
to the state.  The object updates the state in response to messages
from other objects.  It can then be single-threaded internally with each
object having its own thread.  Since CML threads are light-weight it is
not a problem to have large numbers of threads.</P
><P
>The model I'm describing here appears more explicitly in other concurrent
languages as a coordination sub-language.  These languages have two parts,
a sequential language for manipulating the data and a coordination
language to control the interaction between the concurrent objects.</P
><P
>An example of a coordination language is Linda[<SPAN
CLASS="CITATION"
><A
HREF="b6666.html#BIBE.LINDA"
><I
>Linda</I
></A
></SPAN
>].  Linda
is independent of the data language and can be used with a variety of
languages, even C.  Another interesting language is COOL, the Crisp object
coordination language[<SPAN
CLASS="CITATION"
><A
HREF="b6666.html#BIBE.COOLCRISP"
><I
>CoolCrisp</I
></A
></SPAN
>].  This coordinates concurrent
objects called actors. The actors typically implement finite-state
machines. They communicate via asynchronous messages (rather than the
synchronous messages of CML).  Getting closer to functional languages,
there is the new research language called Hume[<SPAN
CLASS="CITATION"
><A
HREF="b6666.html#BIBE.HUME"
><I
>Hume</I
></A
></SPAN
>]. This has
a restricted purely functional language in the Haskell mold for the
data language.  All imperative state is handled at the level of the
coordination language.  Search for &quot;coordination language&quot; at Google
for more examples.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CMLMODELCHANNELS"
>CML Channels</A
></H2
><P
>A channel is a rendezvous point between two threads that allows them
to pass a value.  The value passing is synchronous.  The sender of the
value waits for the receiver and the receiver waits for the sender.</P
><P
>Each channel you create has a fixed type.  The type of a channel is
defined in the CML structure named <TT
CLASS="COMPUTEROUTPUT"
>CML</TT
><A
NAME="AEN2486"
HREF="#FTN.AEN2486"
>[1]</A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type 'a chan</PRE
></TD
></TR
></TABLE
><P
>The type variable <TT
CLASS="COMPUTEROUTPUT"
>'a</TT
> is the place holder for the type of values
passed through the channel.  If you want to pass more than one type of
value then you will need to either combine them in a datatype  or use
more than one channel.</P
><P
>Channels are bidirectional.  Any pair of sending thread and receiving
thread can use a channel. The following functions defined in the
<TT
CLASS="COMPUTEROUTPUT"
>CML</TT
> structure deal with channels.  (See the <TT
CLASS="COMPUTEROUTPUT"
>CML</TT
> structure
for more channel handling functions.)</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val channel     : unit -&#62; 'a chan 
val send        : ('a chan * 'a) -&#62; unit 
val recv        : 'a chan -&#62; 'a 
val sendEvt     : ('a chan * 'a) -&#62; unit event 
val recvEvt     : 'a chan -&#62; 'a event </PRE
></TD
></TR
></TABLE
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>channel</TT
> function creates a new channel.  The <TT
CLASS="COMPUTEROUTPUT"
>send</TT
> and
<TT
CLASS="COMPUTEROUTPUT"
>recv</TT
> functions do just what the name says. The <TT
CLASS="COMPUTEROUTPUT"
>sendEvt</TT
> and
<TT
CLASS="COMPUTEROUTPUT"
>recvEvt</TT
> functions return events (described in the next section).
The event functions allow a thread to choose between several send or
receive operations.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CMLMODELEVENTS"
>CML Events</A
></H2
><P
>An event represents some activity that will be completed at a later
time. An event is treated like any other value so it can be passed around
and stored.  An event is said to be <I
CLASS="EMPHASIS"
>enabled</I
> when its activity
is completed. For example an event might represent the reception of a
message on a channel or the completion of some I/O activity.</P
><P
>A program can choose to wait for an event to be completed.  The act
of waiting is called <I
CLASS="EMPHASIS"
>synchronising</I
> and is independent of launching
the activity that the event represents.  The program can choose one
from a collection of events to synchronise on.  This is similar to the
traditional <TT
CLASS="COMPUTEROUTPUT"
>select</TT
> or <TT
CLASS="COMPUTEROUTPUT"
>poll</TT
> system call of Unix but it is
more general.  An event can represent any concurrent activity such as
the completion of a thread.</P
><P
>The type of an event is defined in the <TT
CLASS="COMPUTEROUTPUT"
>CML</TT
> structure.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>type 'a event</PRE
></TD
></TR
></TABLE
><P
>An event has an associated data value that is returned when the program
synchronises on the event.  The type variable <TT
CLASS="COMPUTEROUTPUT"
>'a</TT
> is a place-holder
for the value's type.  The following functions defined in the <TT
CLASS="COMPUTEROUTPUT"
>CML</TT
>
structure handle collections of events.  (See the <TT
CLASS="COMPUTEROUTPUT"
>CML</TT
> structure
for more event handling functions.)</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val wrap       : ('a event * ('a -&#62; 'b)) -&#62; 'b event 
val choose     : 'a event list -&#62; 'a event 
val sync       : 'a event -&#62; 'a 
val select     : 'a event list -&#62; 'a 
val guard      : (unit -&#62; 'a event) -&#62; 'a event 
val timeOutEvt : Time.time -&#62; unit event 
val atTimeEvt  : Time.time -&#62; unit event </PRE
></TD
></TR
></TABLE
><P
>These functions build up a representation of a network of events.
The <TT
CLASS="COMPUTEROUTPUT"
>wrap</TT
> function associates a function with an event which
will process the event's value after the event is synchronised on.
The <TT
CLASS="COMPUTEROUTPUT"
>choose</TT
> function represents the choice of one event from the
list of events.  The choice is not actually made until a synchronisation
is attempted.  Then the first enabled event from the list is chosen or
if several are enabled then one of them is chosen non-deterministically.
A synchronisation is performed on the chosen event returning the event's
value.  </P
><P
>The following code illustrates the interaction of <TT
CLASS="COMPUTEROUTPUT"
>wrap</TT
> and
<TT
CLASS="COMPUTEROUTPUT"
>choose</TT
>.  The <TT
CLASS="COMPUTEROUTPUT"
>bev</TT
> values are base events such as the
reception of a message.  The <TT
CLASS="COMPUTEROUTPUT"
>w</TT
> values are wrapping functions.</P
><TABLE
BORDER="0"
BGCOLOR="#d0ffff"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>val ev = choose [
    wrap (bev1, w1),
    wrap (choose [
        wrap (bev2, w2),
        wrap (bev3, w3)
        ], w4)
    ]</PRE
></TD
></TR
></TABLE
><P
><A
HREF="x2442.html#EVENTTREE"
>Figure 6-4</A
> shows the network of events that results. The
nodes labelled with &quot;<TT
CLASS="COMPUTEROUTPUT"
>|</TT
>&quot; represent choices. When a synchronisation
is attempted on the event <TT
CLASS="COMPUTEROUTPUT"
>ev</TT
> then the program will wait for one
of the events <TT
CLASS="COMPUTEROUTPUT"
>bev1</TT
>, <TT
CLASS="COMPUTEROUTPUT"
>bev2</TT
> or <TT
CLASS="COMPUTEROUTPUT"
>bev3</TT
> to be enabled.
If <TT
CLASS="COMPUTEROUTPUT"
>bev2</TT
> is the first to be enabled then its returned value will
be run through the <TT
CLASS="COMPUTEROUTPUT"
>w2</TT
> and <TT
CLASS="COMPUTEROUTPUT"
>w4</TT
> functions in that order to
produce the value returned by the <TT
CLASS="COMPUTEROUTPUT"
>ev</TT
> event.</P
><DIV
CLASS="FIGURE"
><A
NAME="EVENTTREE"
></A
><P
><B
>Figure 6-4. A Network of Events</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><center><IMG
SRC="concur/eventTree.png"
></center></IMG
></P
></DIV
></DIV
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>sync</TT
> function waits for an event. The <TT
CLASS="COMPUTEROUTPUT"
>select</TT
> function
is equivalent to <TT
CLASS="COMPUTEROUTPUT"
>choose</TT
> and then a <TT
CLASS="COMPUTEROUTPUT"
>sync</TT
> but is more efficient.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>guard</TT
> function associates a function with an event to be run
at the time of synchronisation. The function will typically be used to
make preparations for the event.  This is useful in a choice of events
to have preparations specific to each event.</P
><P
>The <TT
CLASS="COMPUTEROUTPUT"
>timeOutEvt</TT
> function produces an event that becomes enabled
after some time interval has passed. The <TT
CLASS="COMPUTEROUTPUT"
>atTimeEvt</TT
> function is
similar but it becomes enabled at a specified point in time.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CMLSYNCVARS"
>Synchronous Variables</A
></H2
><P
>A synchronous variable is a buffer with a capacity for one value that
provides for asynchronous communication between threads. A writer can
put a value into a variable without waiting for a reader.  There are two
kinds, an I-variable is write-once, an M-variable can be written to more
than once.  The writer cannot overwrite the value in an M-variable. It
must wait for it to be emptied by the reader before another value can
be written.  Symmetrically a reader must wait for a writer to put a
value into a variable. CML events are available for waiting on a variable.</P
><P
>I-variables are useful when you want to pass only one message between two
threads. For example when replying from a remote procedure call (RPC).
They are more efficient than channels for this.  For a more complex
example, the CML library provides an implementation of multicasting
using I-variables.</P
><P
>M-variables are a more general-purpose primitive for building up
synchronisation operations.  I've only used them to implement a <I
CLASS="EMPHASIS"
>mutex</I
>
to protect a critical section.  The value in the M-variable can be treated
as a baton which gives access to the critical section.  A thread takes
the baton out of the M-variable, performs the critical code and puts
the baton back into the M-variable.  If another thread tries to take
the baton at the same time it will block because the M-variable is empty.</P
><P
>Synchronous variables are implemented in the <TT
CLASS="COMPUTEROUTPUT"
>SyncVar</TT
> structure
of CML.  See the CML documentation for more details.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CMLMAILBOX"
>Mailboxes</A
></H2
><P
>A mailbox provides a buffer with unlimited capacity for asynchronous
communication between threads.  They are implemented in the <TT
CLASS="COMPUTEROUTPUT"
>Mailbox</TT
>
structure of CML.  Since the capacity is unlimited a program using them
should implement some sort of flow control.</P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN2486"
HREF="x2442.html#AEN2486"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Read the CML
reference documentation along with the following material.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x2405.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x2564.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Coroutines</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c2344.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>A Counter Object</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
